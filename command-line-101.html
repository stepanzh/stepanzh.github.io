<!DOCTYPE html>
<html lang="ru">
  <head>
        <title>stepanzh — Командная оболочка 101</title>
      <meta charset="utf-8" />
      <meta name="generator" content="Pelican" />
      <meta name="viewport" content="width=device-width, initial-scale=1.0">

      <!-- Yandex.Metrika counter -->
      <script type="text/javascript" >
         (function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};
         m[i].l=1*new Date();
         for (var j = 0; j < document.scripts.length; j++) {if (document.scripts[j].src === r) { return; }}
         k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})
         (window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");

         ym(99933624, "init", {
              clickmap:true,
              trackLinks:true,
              accurateTrackBounce:true,
              webvisor:true
         });
      </script>
      <noscript><div><img src="https://mc.yandex.ru/watch/99933624" style="position:absolute; left:-9999px;" alt="" /></div></noscript>
      <!-- /Yandex.Metrika counter -->

      <link rel="preconnect" href="https://fonts.googleapis.com">
      <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
      <link href="https://fonts.googleapis.com/css2?family=PT+Mono&family=PT+Sans+Caption:wght@400;700&family=PT+Sans:ital,wght@0,400;0,700;1,400;1,700&display=swap" rel="stylesheet">
      <link rel="stylesheet" type="text/css" href="https://stepanzh.github.io/theme/css/base.css" />
      <link rel="stylesheet" type="text/css" href="https://stepanzh.github.io/theme/css/highlight.css" />

      <!-- icons -->
      <link rel="icon" href="/favicon.ico" sizes="32x32">
      <link rel="apple-touch-icon" href="/apple-touch-icon.png">



    <meta name="description" content="Заметка для тех, кто работает в терминале и хочет лучше его понять. Речь пойдёт об аргументах, потоках и переменных окружения." />

    <meta name="keywords" content="консоль, терминал, аргумент, поток, переменная окружения, unix, command line, terminal, console, код выхода, интерполяция, цветной вывод, ansi escape code" />

  </head>

  <body>
      <header class="page-header">
          <hgroup>
            <h1>
              <a class="site-name" href="https://stepanzh.github.io/">
                <img src="https://stepanzh.github.io/theme/images/galsia-transparent-500x500.png" />
                <span>stepanzh</span>
              </a>
            </h1>
          </hgroup>
          <nav class="nav-global">
            <span class="page-nav__item"><a href="https://stepanzh.github.io/"  aria-current="page" >Главная</a></span>
                <span class="page-nav__item"><a href="https://stepanzh.github.io/pages/about-proportio.html" >Пропорцио</a></span>
                <span class="page-nav__item"><a href="https://stepanzh.github.io/pages/stepan-zakharov-cv.html" >Cirriculum vitae</a></span>
                <span class="page-nav__item"><a href="https://stepanzh.github.io/pages/my-projects.html" >Проекты</a></span>
                <span class="page-nav__item"><a href="https://stepanzh.github.io/pages/support-me.html" >Поддержать</a></span>
          </nav>
      </header>
      <main class="page-main">
  <article class="article">
    <header>
      <h2 class="article-heading">Командная оболочка 101</h2>
      
    </header>
    <!-- TODO: kbd role -->
<blockquote class="epigraph">
Что происходит под капотом при работе в командной строке?
Заметка для тех, кто работает в терминале и хочет лучше его понять.
Речь пойдёт об аргументах, потоках и переменных окружения.</blockquote>
<p>Проще всего начать с примера. Представьте, что вы открыли терминал,
ввели</p>
<div class="highlight"><pre><span></span>ls<span class="w"> </span>-alt<span class="w"> </span>Downloads
</pre></div>
<p>и нажали <span class="kbd">Enter</span>.
После этого на экране терминала появляется содержимое директории Downloads.
Под капотом отработали терминал, командная оболочка, операционная система и непосредственно программа ls.</p>
<p>Что произошло?
Много работы сделала оболочка.
После нажатия Enter она получила от терминала строку (команду) <code>ls -alt Downloads</code> на обработку.
Сначала оболочка разбила её на массив строк: &quot;ls&quot;, &quot;-alt&quot;, &quot;Downloads&quot;.
Первый элемент массива это название программы, оболочка ушла искать ls среди сотен других.
Затем оболочка вызвала ls и передала ей <em>массив аргументов</em> (&quot;-alt&quot;, &quot;Downloads&quot;), а также <em>стандартный поток вывода</em> stdout.
Далее программа ls прочла переданный ей массив аргументов, отработала в соответствии с ним, и напечатала результат работы в stdout.
А теперь перейдём к скрытым деталям...</p>
<div class="section" id="section-2">
<h2>Аргументы программы в консольном мире</h2>
<p>Начнём с программы ls.
С её точки зрения аргументы это массив строк (см. <a class="reference external" href="https://en.cppreference.com/w/c/language/main_function">int argc, char* argv[]</a>).
Чтобы интерфейс для разных программ был более-менее одинаков, в консольном мире действует множество соглашений.</p>
<p>Соглашение первое.
Аргументы бывают <em>ключевыми</em> и <em>позиционными</em>.
Ключевые аргументы начинаются с черты (&quot;-alt&quot;), и обычно могут передаваться в любом порядке.
Остальные аргументы — позиционные (&quot;Downloads&quot;), и обычно ставятся после ключевых.
Заметьте, что в Python (и многих других языках программирования) всё наоборот: сначала позиционные, затем по ключу!</p>
<p>Создатели ls следуют ещё одному соглашению — можно объединять ключевые аргументы в один, т.е. <code>-alt</code> для программы ls это то же, что и три аргумента: <code>-a -l -t</code>.
Все эти три аргумента работают как флаги, переключатели: &quot;-a&quot; показывает (скрытые) файлы, &quot;-l&quot; включает техническую сводку о каждом файле, а &quot;-t&quot; сортирует файлы по моменту изменения.</p>
<p>А что если аргумент по ключу требует значения?
Значение пишется через пробел или знак равенства после ключа, например, <code>ls --color=never</code>.
В этом примере есть ещё одно соглашение: у ключей бывает два имени — короткое и полное (<code>python -h</code> и <code>python --help</code>).</p>
</div>
<div class="section" id="section-3">
<h2>Потоки</h2>
<p>На самом деле, оболочка передаёт не один, а сразу три потока программе.
Потоки нужны для ввода и вывода информации, это своего рода каналы общения с программой, которые можно переключать.</p>
<p><em>Поток вывода stdout</em> используется для вывода программой результата.
Именно сюда по умолчанию пишут функции вроде <code>print</code>.</p>
<p><em>Поток ошибок stderr</em> используется для вывода служебных, информирующих сообщений.
На практике, сюда пишутся логи и отладочная информация.</p>
<p>Наконец, <em>поток ввода stdin</em> передаётся оболочкой для чтения данных программой.
Именно этот поток читается функциями вроде <code>input</code>, <code>readline</code> или <code>getchar</code>.</p>
<p>При программировании работа c потоками обычно доступна в стандартной библиотеке, например, в Python см. модуль <a class="reference external" href="https://docs.python.org/3/library/sys.html">sys</a>.</p>
<div class="section" id="section-4">
<h3>А что ж такое поток?</h3>
<p>Поток это последовательность байт.
(Да, абстрактней остались только байт и бит.)
Поток можно читать, и можно в него писать.
Вопрос в том, как его интерпретировать.
При работе в консоли, всё, что вываливается на экран, интерпретируется как текст.
Но ничто не мешает вывалить на экран терминала картинку (<code>cat wallpaper.png</code>).</p>
<p>Поток это абстракция, которая унифицирует интерфейс чтения и записи куда-либо, вообще.
Используя её, мы можем одинаково работать с выводом в терминал, файл или сетевой сокет.
Под капотом операционная система выделяет буферную память под поток, и мы работаем с этой памятью.
Содержимое буфера существует само по себе до момента &quot;смытия&quot; (flush).
В этот момент, то, что было в буфере, отправляется далее, например, в терминал, файл или сокет.</p>
<p>Используйте потоки в своих программах, особенно при создании библиотек.
Лучше, когда ваши функции пишут в потоки, а не в файлы или на экран.
Такой код гибче и его легче тестировать.
Например, вместо того, чтобы создавать и писать в файл, можно писать в текстовый поток, а потом сравнить его содержимое с эталонной строкой.</p>
</div>
<div class="section" id="section-5">
<h3>Перенаправление потоков</h3>
<p>Вернёмся к потокам std.
Киллер-фича консольного мира — перенаправление потоков.
С помощью <code>1&gt;</code> вы можете перенаправить стандартный поток вывода в файл.</p>
<div class="highlight"><pre><span></span>ls<span class="w"> </span>-alt<span class="w"> </span>Downloads<span class="w"> </span><span class="m">1</span>&gt;<span class="w"> </span>file-list.txt
</pre></div>
<p>Аналогично с потоком ошибок, но используется «кран» <code>2&gt;</code>.
Вы можете направлять потоки вывода и ошибок в разные файлы, а можете в один, «краном» <code>&gt;</code>.</p>
<p>А чтобы сменить поток ввода, используется <code>&lt;</code>.
Например, в команде</p>
<div class="highlight"><pre><span></span>ls<span class="w"> </span>&lt;<span class="w"> </span>my-list.txt
</pre></div>
<p>программа ls будет читать список директорий из файла my-list.txt.
Помните задания по информатике, где нужно было читать ввод с клавиатуры?
Так вот, у проверяющего скрипта никакой клавиатуры нет, вместо неё он подаёт на stdin вашей программы файл с входными данными, обёрнутый в поток.</p>
<p>Консольные программы часто создаются так, что вывод одной программы можно соединить с вводом второй.
Для этого используется <em>конвейер</em> (pipe) <code>|</code>.
Например,</p>
<div class="highlight"><pre><span></span>ls<span class="w"> </span>-1<span class="w"> </span>Downloads<span class="w"> </span><span class="p">|</span><span class="w"> </span>wc<span class="w"> </span>-l
</pre></div>
<p>выведет на экран количество файлов в директории Downloads.
В целом, консольный unix-мир состоит из маленьких утилит, хорошо делающих свои маленькие задачи, а конвейер позволяет собирать из утилит более сложные программы.
С принципом конвейера вы можете встретиться при обработке массива данных: достать, отфильтровать, отсортировать, применить функцию и отдать.</p>
</div>
</div>
<div class="section" id="section-6">
<h2>Переменные окружения</h2>
<div class="highlight"><pre><span></span>env<span class="w"> </span><span class="p">|</span><span class="w"> </span>tail

<span class="nv">LANG</span><span class="o">=</span>ru_RU.UTF-8
<span class="nv">SHELL</span><span class="o">=</span>/bin/zsh
<span class="nv">TERM_PROGRAM</span><span class="o">=</span>iTerm.app
<span class="nv">TERM</span><span class="o">=</span>xterm-256color
<span class="nv">HOME</span><span class="o">=</span>/Users/stepanzh
<span class="nv">USER</span><span class="o">=</span>stepanzh
<span class="nv">ZSH</span><span class="o">=</span>/Users/stepanzh/.oh-my-zsh
<span class="nv">PAGER</span><span class="o">=</span>less
<span class="nv">LSCOLORS</span><span class="o">=</span>Gxfxcxdxbxegedabagacad
<span class="nv">EDITOR</span><span class="o">=</span>nvim
</pre></div>
<p>Кроме потоков и аргументов, оболочка передаёт программе <em>переменные окружения</em> (environment).
Чаще всего, они используются как набор настроек по умолчанию.
Их можно просмотреть командой env, и программно доступиться через <code>getenv</code>, <code>ENV</code>, <code>os.environ</code> или что-то подобное.
Например, программа ls читает переменную <code>LSCOLORS</code>, чтобы подкрасить типы файлов цветами (файл, директория, ссылка, исполняемый файл и т.п.).</p>
<p>Переменные окружения организованы в словарь ключ-значение.
Значения и ключи только строковые, а сам словарь глобальный, для всех программ.
Однако его можно менять на время команды или вовсе подавать пустой.</p>
<div class="section" id="openblas-numpy">
<h3>Пример про OpenBLAS и numpy</h3>
<p>Пример посложнее.
Попробуйте запустить какую-нибудь долгую (хотя бы минута) программу с numpy двумя командами:</p>
<div class="highlight"><pre><span></span>python<span class="w"> </span>main.py

<span class="nv">OPENBLAS_NUM_THREADS</span><span class="o">=</span>X<span class="w"> </span>python<span class="w"> </span>main.py
</pre></div>
<p>где X это число ядер вашего процессора.
Скорее всего, второй пример будет работать существенно быстрее.
Почему?</p>
<p>По умолчанию, <a class="reference external" href="https://numpy.org/">numpy</a> использует библиотеку <a class="reference external" href="https://github.com/OpenMathLib/OpenBLAS">OpenBLAS</a> для линейной алгебры.
А OpenBLAS использует столько потоков (threads), сколько указано в переменной окружения <code>OPENBLAS_NUM_THREADS</code>.
Беда в том, что по умолчанию эта переменная не проставлена, и OpenBLAS использует все потоки, включая логические.
В нагруженном вычислениями коде это обычно нежелательно, и стоит использовать столько потоков, сколько ядер в процессоре.</p>
</div>
<div class="section" id="path">
<h3>Переменная PATH</h3>
<p>Одна из важнейших переменных окружения называется PATH.
Она содержит список директорий, где оболочка ищет программы, например, ls.
Когда вы устанавливаете новую консольную программу, вы можете добавить путь до неё в PATH, чтобы вызывать программу по названию, а не полному пути.
Но ещё лучше создать ссылку в директории, которая уже есть в PATH.
В unix-ах есть стандартное место для таких случаев — <code>/usr/local/bin</code>.</p>
</div>
</div>
<div class="section" id="section-7">
<h2>А что ещё?</h2>
<div class="section" id="section-8">
<h3>Код выхода</h3>
<p>Всякая программа имеет <em>код выхода</em> (exit code, код ошибки).
Он хранится в специальной переменной &quot;?&quot;.</p>
<div class="highlight"><pre><span></span><span class="nb">echo</span><span class="w"> </span><span class="nv">$?</span>
</pre></div>
<p>Код 0 (ноль) по соглашению показывает отсутствие ошибки.</p>
<p>При написании однострочников часто используется оператор <code>&amp;&amp;</code>.</p>
<div class="highlight"><pre><span></span>ls<span class="w"> </span>Downloads<span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="nb">echo</span><span class="w"> </span>hello
</pre></div>
<p>Этот оператор проверяет код выхода, и, если код ошибочный, цепочка команд после оператора не выполняется.</p>
</div>
<div class="section" id="section-9">
<h3>Интерполяция переменных</h3>
<p>При создании массива аргументов для программы, оболочка интерполирует значения переменных и даже результаты других команд.
Например, при вызове</p>
<div class="highlight"><pre><span></span>ls<span class="w"> </span><span class="nv">$dirout</span>
</pre></div>
<p>оболочка подставит значение переменной <code>dirout</code>.</p>
<p>Интерполирование опасно, когда переменные хранят значения с пробелами: так один аргумент может превратиться в несколько.
Для экранирования пробелов в переменных используются двойные кавычки, а одинарные отключают интерполирование.
Поэтому в консольном мире распространены имена файлов <a class="reference external" href="https://stepanzh.github.io/note-on-kebab-case.html">без пробелов</a>.</p>
</div>
<div class="section" id="alias">
<h3>Интерполяция alias</h3>
<p>Многие unix-оболочки предоставляют механизм alias, который по сути является сокращением команд.
Например, объявив</p>
<div class="highlight"><pre><span></span><span class="nb">alias</span><span class="w"> </span><span class="nv">gst</span><span class="o">=</span><span class="s1">&#39;git status&#39;</span>
</pre></div>
<p>Вы сможете по alias <code>gst</code> вызывать команду <code>git status</code>.
Я нахожу это очень удобным в ежедневной работе, хотя многие предпочитают использовать полноценные функции вместо alias-ов.
Да, современная оболочка имеет полноценный язык программирования.
Чтобы функции и alias-ы были доступны всегда, их сохраняют в стартап-файле оболочки.</p>
<p>Чаще всего я использую такие alias-ы</p>
<div class="highlight"><pre><span></span><span class="nb">alias</span><span class="w"> </span><span class="nv">gc</span><span class="o">=</span><span class="s1">&#39;git commit&#39;</span>
<span class="nb">alias</span><span class="w"> </span><span class="nv">gd</span><span class="o">=</span><span class="s1">&#39;git diff&#39;</span>
<span class="nb">alias</span><span class="w"> </span><span class="nv">gl</span><span class="o">=</span><span class="s1">&#39;git pull&#39;</span>
<span class="nb">alias</span><span class="w"> </span><span class="nv">gp</span><span class="o">=</span><span class="s1">&#39;git push&#39;</span>
<span class="nb">alias</span><span class="w"> </span><span class="nv">gst</span><span class="o">=</span><span class="s1">&#39;git status&#39;</span>

<span class="nb">alias</span><span class="w"> </span>..<span class="o">=</span><span class="s1">&#39;cd ..&#39;</span>

<span class="nb">alias</span><span class="w"> </span><span class="nv">ll</span><span class="o">=</span><span class="s1">&#39;ls -lh&#39;</span>
</pre></div>
<p>Alias-ы интерполируются, при наборе команды вы можете считать, что alias просто подставляется.</p>
<div class="highlight"><pre><span></span>gc<span class="w"> </span>-m<span class="w"> </span><span class="s1">&#39;feat: new article on command line basics&#39;</span>
</pre></div>
<p>Ещё я люблю пользоваться <a class="reference external" href="http://www.gnuplot.info/">gnuplot</a> для построения графиков.
Когда мне часто требуется построить результаты расчёта, я сохранию gnuplot-скрипт, который ожидает на вход файл с данными, а выдаёт pdf-ку.
Так, я использую alias <code>plt</code>.</p>
<div class="highlight"><pre><span></span><span class="nb">alias</span><span class="w"> </span><span class="nv">plt</span><span class="o">=</span><span class="s1">&#39;gnuplot -c&#39;</span>

plt<span class="w"> </span>residual-norm.gnuplot<span class="w"> </span>benchmark-summary.tsv<span class="w"> </span>&gt;<span class="w"> </span>/tmp/residual-norm.pdf
open<span class="w"> </span>/tmp/residual-norm.pdf
</pre></div>
<p>С таким подходом я за дешёво контролирую что построить и куда положить картинку.
Например, в связке Python + <a class="reference external" href="https://matplotlib.org/">matplotlib</a> получилось бы куда больше бойлерплейта (и, вероятно, медленнее бы работало).</p>
</div>
</div>
<div class="section" id="section-10">
<h2>Бонус. Как вывод программы становится цветным? Оболочка и терминал.</h2>
<p>За цветную печать на экран отвечают текстовые коды <a class="reference external" href="https://en.wikipedia.org/wiki/ANSI_escape_code">ANSI escape sequences</a>.
Но прежде следует отличать командную оболочку от терминала.</p>
<p>Оболочка это <em>софт</em>, который даёт доступ к работе с программами на компьютере из терминала.
Оболочка определяет, где ищутся программы, как интерполируются переменные, предоставляет скриптовый язык и, например, подсказывает ввод на <span class="kbd">Tab</span>.</p>
<p>А вот терминал это другое.
Терминал раньше — это <em>физическое устройство</em> ввода-вывода для компа размером с комнату.
Попросту говоря, это монитор и клавиатура, причём монитор мог поддерживать цвета.
Сейчас же терминал это программа, <em>эмулирующая</em> возможности тех, физических терминалов.
Физический современный терминал можно встретить в дата-центрах и серверных.</p>
<p>Вернёмся к ANSI кодам.
Это текстовые коды, которые интерпретируются терминалом (программой, а не оболочкой) как форматирующие: красящие, подчёркивающие, ожирняющие и т.п.
Когда терминал встречает форматирующий код, то он его не печатает, а лишь применяет форматирование ко всему последующему, например, пишет красным цветом.
Также есть код, который сбрасывает форматирование на обычное.
Подробней можно почитать тут <a class="reference external" href="https://www.lihaoyi.com/post/BuildyourownCommandLinewithANSIescapecodes.html">lihaoyi.com</a>.</p>
<p>Эмуляторов физических терминалов много, по умолчанию же используется  какой-нибудь популярный, вроде xterm-256color.</p>
<p>Самая широкая палитра ANSI кодов насчитывает 256 цветов, а также форматирующие модификаторы (жирность, подчёркнутость, фон и т.п.).
Кроме того, коды позволяют перемещать курсор не только в строке ввода, но и во всей области экрана, если эмулятор это поддерживает.
В таких терминалах можно создавать программы с текстовым интерфейсом, как в vim или Midnight Commander.</p>
</div>

    <footer class="article-footer">
      <p class="article-date">
        <time datetime="2025-01-28T00:00:00+03:00">2025-01-28</time>.          Обновлено <time datetime="2025-05-14T00:00:00+03:00">2025-05-14</time>.
      </p>
      <section class="article-footer__actions">
        <div><a href="https://stepanzh.github.io/pages/support-me.html" rel="bookmark">❤️ Поблагодарить автора</a></div>
        <div><a href="https://t.me/stepanzh_blog" rel="nofollow">👀 Подписаться на новости</a></div>
      </section>
    </footer>
  </article>
      </main>
      <footer class="page-footer">
          <p>&copy; Захаров Степан</p>
          <p>Сайт создан с помощью <a target="_blank" rel="nofollow" href="https://getpelican.com/">Pelican</a></p>
      </footer>
  </body>
</html>