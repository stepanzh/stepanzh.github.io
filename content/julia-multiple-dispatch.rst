Сердце языка Julia — множественная диспетчеризация
##################################################

:date: 2025-05-12
:slug: julia-multiple-dispatch
:summary: todo
:description: todo
:keywords: todo


TODO: epigraph (2025-05-12 by Stepan Zakharov)

Приступим
---------

Я начну с примера.
В языке Julia можно так.

.. code-block:: julia-repl
  :linenos: table

  julia> f(x, y) = "default";

  julia> f(x::T, y::T) where {T} = "default when x and y have same type";

  julia> f(x::Int, y::Int) = "x is Int, y is Int";

  julia> f(x::Int, y::Float64) = "x is Int, y is Float64";
  
  julia> f(x, y, z) = "oh my, there are x, y and even z!";

  julia> f("a", 1)
  "default"

  julia> f("a", "b")
  "default when x and y have same type"

  julia> f(1, 2)
  "x is Int, y is Int"

  julia> f(1, 2.0)
  "x is Int, y is Float64"

  julia> f(1, 2, 3)
  "oh my, there are x, y and even z!"

Выше определена одна функция :code:`f`.

.. code-block:: julia-repl

  julia> f
  f (generic function with 5 methods)

И пять методов для неё.

.. code-block:: julia-repl

  julia> methods(f)
   [1] f(x::Int64, y::Float64)
   [2] f(x::Int64, y::Int64)
   [3] f(x, y, z)
   [4] f(x::T, y::T) where T
   [5] f(x, y)

.. 

  Julia не объектно-ориентированный язык: здесь *методы принадлежат не объектам, а функциям*.

Когда функция вызывается, то диспетчер просматривает, какие есть методы у функции и выбирает тот, который лучшим образом подходит.
«Выбрать лучшим образом» значит выбрать метод, типы аргументов которого наиболее «близки» к типам передаваемых аргументов.
В случае вызова :code:`f(1, 2)` подходят сразу три метода:

- :code:`f(x, y)`,
- :code:`f(x::T, y::T) where {T}`,
- :code:`f(x::Int64, y::Int64)`.

Но вызывается последний, потому что типы аргументов (числа 1 и 2) наиболее близки к :code:`Int64` и :code:`Int64` (вообще, они совпадают с ними). 

.. 

  Итак, диспетчеризация это процесс выбора метода для конкретного вызова функции.

А что значит «множественная диспетчеризация» (multiple dispatch)?

.. 

  Множественная диспетчеризация это вид диспетчеризации, который учитывает типы **нескольких аргументов**.

В случае Julia учитываются типы всех *позиционных аргументов* (positional arguments), а вот диспетчеризацию для аргументов по ключу (keyword arguments) не завезли.

Что ещё можно почерпнуть из примеров выше?
==========================================

Декларация не нужна
~~~~~~~~~~~~~~~~~~~

Не обязательно декларировать тип(ы) аргументов функции.

.. code-block:: julia-repl

  julia> f(x, y) = "default";

На самом деле, декларация здесь есть, но неявная.
Этот пример эквивалентен такому.

.. code-block:: julia-repl

  julia> f(x::Any, y::Any) = "default";

Тип :code:`Any` особый, он «прародитель» всех других.
На самом деле, в Julia нет привычного для ООП наследования (inheritance).
Поэтому нет и родительских отношений между типами.

Однако, типы организованы иерархически, в виде дерева.
Корнем этого дерева является тип :code:`Any`.
А все остальные с ним связаны: опосредованно или напрямую.

Диспатч на абстрактных типах
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Можно диспетчеризовываться не только на конкретных, но и на абстрактных типах.

.. code-block:: julia-repl

   julia> f(x, y) = "default";

   julia> f(x::Int, y::Int) = "x is Int, y is Int";

   julia> f(x::Real, y::Real) = "x and y are real numbers";

(Последний пример для наглядности, тип :code:`Real` служит для представления всех действительных чисел.)

Абстрактные типы (abstract types), например, :code:`Any` и :code:`Real`, используются только для построения дерева типов.
Они несут только семантику.
А вот про конкретные типы (сoncrete types) компилятору всё известно, включая то, как они представлены в памяти (memory layout).
Они представляют реально существующие в памяти объекты, имеющие значения (value).

Диспатч на количестве аргументов
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Методы могут иметь разное количество аргументов, а диспетчеризация это учитывает.

.. code-block:: julia-repl

  julia> f(x, y) = "default";

  julia> f(x, y, z) = "oh my, there are x, y and even z!";

Generic programming included
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Julia поддерживает обобщённую (generic) парадигму.

.. code-block:: julia-repl

  julia> f(x::T, y::T) where {T} = "default when x and y have same type";

Здесь в одной строчке опеределяется семейство методов, у которых два аргумента, имеющих одинаковый тип (и он назван :code:`T`).

Кстати, тип аргументов доступен как в рантайме (runtime) так и во время компиляции (compile time).

.. code-block:: julia-repl

  julia> atruntime(x) = typeof(x);

  julia> atcompiletime(x::T) where {T} = T;

  julia> atruntime(π)
  Irrational{:π}

  julia> atcompiletime(π)
  Irrational{:π}

У Julia из коробки just-in-time компиляция.
Знать типы во время компиляции бывает необходимо, чтобы дешёво извлечь информацию об аргументах.
Например, так можно узнать размерность массива :code:`ndims(x)` или тип его элементов :code:`eltype(x)`.

Пример обобщённого программирования в Julia
-------------------------------------------

В Julia очень много маленьких функций, которые помогают писать generic код.
Например, самописный generic сумматор выглядит так.

.. code-block:: julia-repl

  julia> function mysum(x)
             acc = zero(eltype(x))
             for xi in x
                 acc += xi
             end
             return acc
         end;

  julia> mysum([1, 2, 3])
  6

  julia> mysum(1:10)
  55

Клёво, да?
Первый пример для массива из трёх элементов.
А во втором :code:`1:10` это арифметическая прогрессия от 1 до 10 с единичным шагом.

Так, стоп.
А зачем нам суммировать все элементы прогрессии, если можно найти сумму за :math:`O(1)` так

.. math::

   \frac{(x_{1} + x_{n}) \times n}{2}

Исправляем!

.. code-block:: julia-repl

  julia> mysum(x::AbstractRange{<:Number}) = (first(x) + last(x)) * length(x) / 2;

  julia> mysum(1:10)
  55.0

Почти готово, но есть косяк — сумма прогрессии целых чисел это всегда целое число, не дробное.
Исправим, накинув ещё один метод!

.. code-block:: julia-repl

  julia> mysum(x::AbstractRange{<:Integer}) = (first(x) + last(x)) * length(x) ÷ 2;

  julia> mysum(1:10)
  55

Вот теперь хорошо.

В дальнейшем можно накинуть низкоуровневых оптимизаций: накидать потоков и `SIMD <https://en.wikipedia.org/wiki/Single_instruction,_multiple_data>`_ инструкций, но щас не об этом.

Итого, сумма элементов массива, как ей и положено, считается за :math:`O(n)`, а сумма арифметической прогрессии за :math:`O(1)`.

.. code-block:: julia-repl

  julia> using BenchmarkTools

  julia> @btime mysum(1:10^6);
    0.791 ns (0 allocations: 0 bytes)

  julia> @btime mysum(1:10^8);
    0.791 ns (0 allocations: 0 bytes)

Пара слов о Python
==================

А Python так может?
К сожалению, нет.
В Python отсутствует magick метод :code:`__sum__`.

.. code-block:: ipython

  In [1]: %timeit sum(range(1, 10**6 + 1))
  9.52 ms ± 36.5 μs per loop (mean ± std. dev. of 7 runs, 100 loops each)

  In [2]: %timeit sum(range(1, 10**8 + 1))
  951 ms ± 1.51 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)

Плак-плак.
Но оно может ему (Пайтону) и не надо.

Диспатч в Python
~~~~~~~~~~~~~~~~

В Python есть диспетчеризация, но она одинарная (single dispatch).
В Python класс это пространство имён, а когда происходит вызов :code:`x + y`, то под капотом интерпретатор делает примерно следующее.

.. code-block:: python

   x + y
   → x.__add__(y)
   → type(x).__add__(x, y)

Где :code:`type(x)` превращается в :code:`int`, :code:`list` или чем там :code:`x` является в рантайме.
Это и есть диспетчеризация, но по типу только первого аргумента.
(Если вы раньше не знали, зачем писать в Python методах :code:`self`, то теперь видите? 😏)

Система типов в Julia
---------------------

Вернёмся к вопросу как диспетчер выбирает метод.
Я упоминал, что правило примерно такое: метод выбирается тот, сигнатура которого наиболее близка к сигнатуре вызова.
Я доподлинно не знаю всех правил диспетчеризации.
Но она становится интуитивно понятной, если знать систему типов Julia.

.. 

  В Julia типы организованы в иерархию типа дерево.

Ниже часть этого дерева.

.. code-block:: text

  Any
  └─ Number
     ├─ Complex
     │  ├─ Complex{Int64}
     │  ├─ Complex{Float64}
     │  └─ ...
     └─ Real
        ├─ AbstractFloat
        │  ├─ BigFloat
        │  ├─ Float16
        │  ├─ Float32
        │  └─ Float64
        ├─ ...
        ├─ Integer
        │  ├─ Bool
        │  ├─ Signed
        │  │  ├─ BigInt
        │  │  ├─ Int128
        │  │  ├─ Int16
        │  │  ├─ Int32
        │  │  ├─ Int64
        │  │  └─ Int8
        │  └─ Unsigned
        │     ├─ UInt128
        │     ├─ UInt16
        │     ├─ UInt32
        │     ├─ UInt64
        │     └─ UInt8
        └─ Rational
           ├─ Rational{Int32}
           ├─ Rational{Int64}
           └─ ...

Эта ветвь содержит (почти) все типы для чисел «из коробки».
Например, цепочка от :code:`Int64` до :code:`Any` такая.

.. code-block:: julia-repl

  julia> Int64 <: Signed <: Integer <: Real <: Number <: Any
  true

Корень дерева это тип :code:`Any`.
А все типы в дереве делятся на два вида: абстрактный (abstract) или конкретный (concrete).

Конкретные типы это листья дерева.
Про них компилятору известно всё, включая их устройство в памяти.
С ними можно считать в рантайме.
А абстрактные типы используются для упорядочивания системы типов в дерево, чтобы можно было писать generic код.

Помните, что диспетчеризация работает для абстрактных типов?
Так вот, когда мы пишем метод для абстрактного типа, например, :code:`f(x::Real)`, мы пишем его для типов всей ветви, начиная с типа :code:`Real`.

Но есть нюанс.
Метод может не работать для некоторых типов ветви.
Например, наш метод :code:`f(x::Real)` может использовать :code:`eps(x)`, эта функция возвращает машинную точность для значения :code:`x`.
Но :code:`eps(x)` определена только для чисел с плавающей точкой (ну ещё для дат, но щас не об этом).
Поэтому вызов :code:`f(1)` может не сработать, если мы не позаботились о случае :code:`eps(1)`.
На выручку нам может прийти функция :code:`float(x)`, которая приводит число к числу с плавающей точкой.

Или пример попроще.
Скажем, мы написали генератор последовательности Фиббоначи.
Если мы его правильно встроили в дерево типов, то есть шанс, что дефолтные :code:`length(x)`, :code:`first(x)` или :code:`last(x)` отработают правильно (но может не эффективно, как в примере с :code:`mysum`).
А если эти методы из коробки не сработают, то придётся написать свои (наследования то нет).

Итак, когда в Julia метод определён для абстрактного типа аргумента, то это не значит, что всё будет работать.
Такое определение метода лишь выражает *намерение*, что работать должно.
А дальше всё зависит от реализации метода, насколько она действительно generic (то есть, от опыта программиста).

TODO: Боль - интерфейсы (2025-05-12 by Stepan Zakharov)
