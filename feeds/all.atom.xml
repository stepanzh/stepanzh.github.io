<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>stepanzh</title><link href="/" rel="alternate"></link><link href="/feeds/all.atom.xml" rel="self"></link><id>/</id><updated>2025-02-11T00:00:00+03:00</updated><entry><title>Командная оболочка 101</title><link href="/command-line-101.html" rel="alternate"></link><published>2025-01-28T00:00:00+03:00</published><updated>2025-02-11T00:00:00+03:00</updated><author><name>Степан Захаров</name></author><id>tag:None,2025-01-28:/command-line-101.html</id><summary type="html">&lt;p class="first last"&gt;Заметка для тех, кто работает в терминале и хочет лучше его понять. Речь пойдёт об аргументах, потоках и переменных окружения.&lt;/p&gt;
</summary><content type="html">&lt;!-- TODO: kbd role --&gt;
&lt;blockquote class="epigraph"&gt;
Что происходит под капотом при работе в командной строке?
Заметка для тех, кто работает в терминале и хочет лучше его понять.
Речь пойдёт об аргументах, потоках и переменных окружения.&lt;/blockquote&gt;
&lt;p&gt;Проще всего начать с примера. Представьте, что вы открыли терминал,
ввели&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="go"&gt;ls -alt Downloads&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;и нажали &lt;span class="kbd"&gt;Enter&lt;/span&gt;.
После этого на экране терминала появляется содержимое директории Downloads.
Под капотом отработали терминал, командная оболочка, операционная система и непосредственно программа ls.&lt;/p&gt;
&lt;p&gt;Что произошло?
Много работы сделала оболочка.
После нажатия Enter она получила от терминала строку (команду) &lt;code&gt;ls -alt Downloads&lt;/code&gt; на обработку.
Сначала оболочка разбила её на массив строк: &amp;quot;ls&amp;quot;, &amp;quot;-alt&amp;quot;, &amp;quot;Downloads&amp;quot;.
Первый элемент массива это название программы, оболочка ушла искать ls среди сотен других.
Затем оболочка вызвала ls и передала ей &lt;em&gt;массив аргументов&lt;/em&gt; (&amp;quot;-alt&amp;quot;, &amp;quot;Downloads&amp;quot;), а также &lt;em&gt;стандартный поток вывода&lt;/em&gt; stdout.
Далее программа ls прочла переданный ей массив аргументов, отработала в соответствии с ним, и напечатала результат работы в stdout.
А теперь перейдём к скрытым деталям...&lt;/p&gt;
&lt;div class="section" id="section-2"&gt;
&lt;h2&gt;Аргументы программы в консольном мире&lt;/h2&gt;
&lt;p&gt;Начнём с программы ls.
С её точки зрения аргументы это массив строк (см. &lt;a class="reference external" href="https://en.cppreference.com/w/c/language/main_function"&gt;int argc, char* argv[]&lt;/a&gt;).
Чтобы интерфейс для разных программ был более-менее одинаков, в консольном мире действует множество соглашений.&lt;/p&gt;
&lt;p&gt;Соглашение первое.
Аргументы бывают &lt;em&gt;ключевыми&lt;/em&gt; и &lt;em&gt;позиционными&lt;/em&gt;.
Ключевые аргументы начинаются с черты (&amp;quot;-alt&amp;quot;), и обычно могут передаваться в любом порядке.
Остальные аргументы — позиционные (&amp;quot;Downloads&amp;quot;), и обычно ставятся после ключевых.
Заметьте, что в Python (и многих других языках программирования) всё наоборот: сначала позиционные, затем по ключу!&lt;/p&gt;
&lt;p&gt;Создатели ls следуют ещё одному соглашению — можно объединять ключевые аргументы в один, т.е. &lt;code&gt;-alt&lt;/code&gt; для программы ls это то же, что и три аргумента: &lt;code&gt;-a -l -t&lt;/code&gt;.
Все эти три аргумента работают как флаги, переключатели: &amp;quot;-a&amp;quot; показывает (скрытые) файлы, &amp;quot;-l&amp;quot; включает техническую сводку о каждом файле, а &amp;quot;-t&amp;quot; сортирует файлы по моменту изменения.&lt;/p&gt;
&lt;p&gt;А что если аргумент по ключу требует значения?
Значение пишется через пробел или знак равенства после ключа, например, &lt;code&gt;ls --color=never&lt;/code&gt;.
В этом примере есть ещё одно соглашение: у ключей бывает два имени — короткое и полное (&lt;code&gt;python -h&lt;/code&gt; и &lt;code&gt;python --help&lt;/code&gt;).&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="section-3"&gt;
&lt;h2&gt;Потоки&lt;/h2&gt;
&lt;p&gt;На самом деле, оболочка передаёт не один, а сразу три потока программе.
Потоки нужны для ввода и вывода информации, это своего рода каналы общения с программой, которые можно переключать.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Поток вывода stdout&lt;/em&gt; используется для вывода программой результата.
Именно сюда по умолчанию пишут функции вроде &lt;code&gt;print&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Поток ошибок stderr&lt;/em&gt; используется для вывода служебных, информирующих сообщений.
На практике, сюда пишутся логи и отладочная информация.&lt;/p&gt;
&lt;p&gt;Наконец, &lt;em&gt;поток ввода stdin&lt;/em&gt; передаётся оболочкой для чтения данных программой.
Именно этот поток читается функциями вроде &lt;code&gt;input&lt;/code&gt;, &lt;code&gt;readline&lt;/code&gt; или &lt;code&gt;getchar&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;При программировании работа c потоками обычно доступна в стандартной библиотеке, например, в Python см. модуль &lt;a class="reference external" href="https://docs.python.org/3/library/sys.html"&gt;sys&lt;/a&gt;.&lt;/p&gt;
&lt;div class="section" id="section-4"&gt;
&lt;h3&gt;А что ж такое поток?&lt;/h3&gt;
&lt;p&gt;Поток это последовательность байт.
(Да, абстрактней остались только байт и бит.)
Поток можно читать, и можно в него писать.
Вопрос в том, как его интерпретировать.
При работе в консоли, всё, что вываливается на экран, интерпретируется как текст.
Но ничто не мешает вывалить на экран терминала картинку (&lt;code&gt;cat wallpaper.png&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;Поток это абстракция, которая унифицирует интерфейс чтения и записи куда-либо, вообще.
Используя её, мы можем одинаково работать с выводом в терминал, файл или сетевой сокет.
Под капотом операционная система выделяет буферную память под поток, и мы работаем с этой памятью.
Содержимое буфера существует само по себе до момента &amp;quot;смытия&amp;quot; (flush).
В этот момент, то, что было в буфере, отправляется далее, например, в терминал, файл или сокет.&lt;/p&gt;
&lt;p&gt;Используйте потоки в своих программах, особенно при создании библиотек.
Лучше, когда ваши функции пишут в потоки, а не в файлы или на экран.
Такой код гибче и его легче тестировать.
Например, вместо того, чтобы создавать и писать в файл, можно писать в текстовый поток, а потом сравнить его содержимое с эталонной строкой.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="section-5"&gt;
&lt;h3&gt;Перенаправление потоков&lt;/h3&gt;
&lt;p&gt;Вернёмся к потокам std.
Киллер-фича консольного мира — перенаправление потоков.
С помощью &lt;code&gt;1&amp;gt;&lt;/code&gt; вы можете перенаправить стандартный поток вывода в файл.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="go"&gt;ls -alt Downloads 1&amp;gt; file-list.txt&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Аналогично с потоком ошибок, но используется «кран» &lt;code&gt;2&amp;gt;&lt;/code&gt;.
Вы можете направлять потоки вывода и ошибок в разные файлы, а можете в один, «краном» &lt;code&gt;&amp;gt;&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;А чтобы сменить поток ввода, используется &lt;code&gt;&amp;lt;&lt;/code&gt;.
Например, в команде&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="go"&gt;ls &amp;lt; my-list.txt&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;программа ls будет читать список директорий из файла my-list.txt.
Помните задания по информатике, где нужно было читать ввод с клавиатуры?
Так вот, у проверяющего скрипта никакой клавиатуры нет, вместо неё он подаёт на stdin вашей программы файл с входными данными, обёрнутый в поток.&lt;/p&gt;
&lt;p&gt;Консольные программы часто создаются так, что вывод одной программы можно соединить с вводом второй.
Для этого используется &lt;em&gt;конвейер&lt;/em&gt; (pipe) &lt;code&gt;|&lt;/code&gt;.
Например,&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="go"&gt;ls -1 Downloads | wc -l&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;выведет на экран количество файлов в директории Downloads.
В целом, консольный unix-мир состоит из маленьких утилит, хорошо делающих свои маленькие задачи, а конвейер позволяет собирать из утилит более сложные программы.
С принципом конвейера вы можете встретиться при обработке массива данных: достать, отфильтровать, отсортировать, применить функцию и отдать.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="section-6"&gt;
&lt;h2&gt;Переменные окружения&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="go"&gt;env | tail&lt;/span&gt;

&lt;span class="go"&gt;LANG=ru_RU.UTF-8&lt;/span&gt;
&lt;span class="go"&gt;SHELL=/bin/zsh&lt;/span&gt;
&lt;span class="go"&gt;TERM_PROGRAM=iTerm.app&lt;/span&gt;
&lt;span class="go"&gt;TERM=xterm-256color&lt;/span&gt;
&lt;span class="go"&gt;HOME=/Users/stepanzh&lt;/span&gt;
&lt;span class="go"&gt;USER=stepanzh&lt;/span&gt;
&lt;span class="go"&gt;ZSH=/Users/stepanzh/.oh-my-zsh&lt;/span&gt;
&lt;span class="go"&gt;PAGER=less&lt;/span&gt;
&lt;span class="go"&gt;LSCOLORS=Gxfxcxdxbxegedabagacad&lt;/span&gt;
&lt;span class="go"&gt;EDITOR=nvim&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Кроме потоков и аргументов, оболочка передаёт программе &lt;em&gt;переменные окружения&lt;/em&gt; (environment).
Чаще всего, они используются как набор настроек по умолчанию.
Их можно просмотреть командой env, и программно доступиться через &lt;code&gt;getenv&lt;/code&gt;, &lt;code&gt;ENV&lt;/code&gt;, &lt;code&gt;os.environ&lt;/code&gt; или что-то подобное.
Например, программа ls читает переменную &lt;code&gt;LSCOLORS&lt;/code&gt;, чтобы подкрасить типы файлов цветами (файл, директория, ссылка, исполняемый файл и т.п.).&lt;/p&gt;
&lt;p&gt;Переменные окружения организованы в словарь ключ-значение.
Значения и ключи только строковые, а сам словарь глобальный, для всех программ.
Однако его можно менять на время команды или вовсе подавать пустой.&lt;/p&gt;
&lt;div class="section" id="openblas-numpy"&gt;
&lt;h3&gt;Пример про OpenBLAS и numpy&lt;/h3&gt;
&lt;p&gt;Пример посложнее.
Попробуйте запустить какую-нибудь долгую (хотя бы минута) программу с numpy двумя командами:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="go"&gt;python main.py&lt;/span&gt;

&lt;span class="go"&gt;OPENBLAS_NUM_THREADS=X python main.py&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;где X это число ядер вашего процессора.
Скорее всего, второй пример будет работать существенно быстрее.
Почему?&lt;/p&gt;
&lt;p&gt;По умолчанию, &lt;a class="reference external" href="https://numpy.org/"&gt;numpy&lt;/a&gt; использует библиотеку &lt;a class="reference external" href="https://github.com/OpenMathLib/OpenBLAS"&gt;OpenBLAS&lt;/a&gt; для линейной алгебры.
А OpenBLAS использует столько потоков (threads), сколько указано в переменной окружения &lt;code&gt;OPENBLAS_NUM_THREADS&lt;/code&gt;.
Беда в том, что по умолчанию эта переменная не проставлена, и OpenBLAS использует все потоки, включая логические.
В нагруженном вычислениями коде это обычно нежелательно, и стоит использовать столько потоков, сколько ядер в процессоре.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="path"&gt;
&lt;h3&gt;Переменная PATH&lt;/h3&gt;
&lt;p&gt;Одна из важнейших переменных окружения называется PATH.
Она содержит список директорий, где оболочка ищет программы, например, ls.
Когда вы устанавливаете новую консольную программу, вы можете добавить путь до неё в PATH, чтобы вызывать программу по названию, а не полному пути.
Но ещё лучше создать ссылку в директории, которая уже есть в PATH.
В unix-ах есть стандартное место для таких случаев — &lt;code&gt;/usr/local/bin&lt;/code&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="section-7"&gt;
&lt;h2&gt;А что ещё?&lt;/h2&gt;
&lt;div class="section" id="section-8"&gt;
&lt;h3&gt;Код выхода&lt;/h3&gt;
&lt;p&gt;Всякая программа имеет &lt;em&gt;код выхода&lt;/em&gt; (exit code, код ошибки).
Он хранится в специальной переменной &amp;quot;?&amp;quot;.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="go"&gt;echo $?&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Код 0 (ноль) по соглашению показывает отсутствие ошибки.&lt;/p&gt;
&lt;p&gt;При написании однострочников часто используется оператор &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="go"&gt;ls Downloads &amp;amp;&amp;amp; echo hello&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Этот оператор проверяет код выхода, и, если код ошибочный, цепочка команд после оператора не выполняется.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="section-9"&gt;
&lt;h3&gt;Интерполяция переменных&lt;/h3&gt;
&lt;p&gt;При создании массива аргументов для программы, оболочка интерполирует значения переменных и даже результаты других команд.
Например, при вызове&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="go"&gt;ls $dirout&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;оболочка подставит значение переменной &lt;code&gt;dirout&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Интерполирование опасно, когда переменные хранят значения с пробелами: так один аргумент может превратиться в несколько.
Для экранирования пробелов в переменных используются двойные кавычки, а одинарные отключают интерполирование.
Поэтому в консольном мире распространены имена файлов &lt;a class="reference external" href="/note-on-kebab-case.html"&gt;без пробелов&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="alias"&gt;
&lt;h3&gt;Интерполяция alias&lt;/h3&gt;
&lt;p&gt;Многие unix-оболочки предоставляют механизм alias, который по сути является сокращением команд.
Например, объявив&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="go"&gt;alias gst=&amp;#39;git status&amp;#39;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Вы сможете по alias &lt;code&gt;gst&lt;/code&gt; вызывать команду &lt;code&gt;git status&lt;/code&gt;.
Я нахожу это очень удобным в ежедневной работе, хотя многие предпочитают использовать полноценные функции вместо alias-ов.
Да, современная оболочка имеет полноценный язык программирования.
Чтобы функции и alias-ы были доступны всегда, их сохраняют в стартап-файле оболочки.&lt;/p&gt;
&lt;p&gt;Чаще всего я использую такие alias-ы&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="go"&gt;alias gc=&amp;#39;git commit&amp;#39;&lt;/span&gt;
&lt;span class="go"&gt;alias gd=&amp;#39;git diff&amp;#39;&lt;/span&gt;
&lt;span class="go"&gt;alias gl=&amp;#39;git pull&amp;#39;&lt;/span&gt;
&lt;span class="go"&gt;alias gp=&amp;#39;git push&amp;#39;&lt;/span&gt;
&lt;span class="go"&gt;alias gst=&amp;#39;git status&amp;#39;&lt;/span&gt;

&lt;span class="go"&gt;alias ..=&amp;#39;cd ..&amp;#39;&lt;/span&gt;

&lt;span class="go"&gt;alias ll=&amp;#39;ls -lh&amp;#39;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Alias-ы интерполируются, при наборе команды вы можете считать, что alias просто подставляется.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="go"&gt;gc -m &amp;#39;feat: new article on command line basics&amp;#39;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Ещё я люблю пользоваться &lt;a class="reference external" href="http://www.gnuplot.info/"&gt;gnuplot&lt;/a&gt; для построения графиков.
Когда мне часто требуется построить результаты расчёта, я сохранию gnuplot-скрипт, который ожидает на вход файл с данными, а выдаёт pdf-ку.
Так, я использую alias &lt;code&gt;plt&lt;/code&gt;.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="go"&gt;alias plt=&amp;#39;gnuplot -c&amp;#39;&lt;/span&gt;

&lt;span class="go"&gt;plt residual-norm.gnuplot benchmark-summary.tsv &amp;gt; /tmp/residual-norm.pdf&lt;/span&gt;
&lt;span class="go"&gt;open /tmp/residual-norm.pdf&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;С таким подходом я за дешёво контролирую что построить и куда положить картинку.
Например, в связке Python + &lt;a class="reference external" href="https://matplotlib.org/"&gt;matplotlib&lt;/a&gt; получилось бы куда больше бойлерплейта (и, вероятно, медленнее бы работало).&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="section-10"&gt;
&lt;h2&gt;Бонус. Как вывод программы становится цветным? Оболочка и терминал.&lt;/h2&gt;
&lt;p&gt;За цветную печать на экран отвечают текстовые коды &lt;a class="reference external" href="https://en.wikipedia.org/wiki/ANSI_escape_code"&gt;ANSI escape sequences&lt;/a&gt;.
Но прежде следует отличать командную оболочку от терминала.&lt;/p&gt;
&lt;p&gt;Оболочка это &lt;em&gt;софт&lt;/em&gt;, который даёт доступ к работе с программами на компьютере из терминала.
Оболочка определяет, где ищутся программы, как интерполируются переменные, предоставляет скриптовый язык и, например, подсказывает ввод на &lt;span class="kbd"&gt;Tab&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;А вот терминал это другое.
Терминал раньше — это &lt;em&gt;физическое устройство&lt;/em&gt; ввода-вывода для компа размером с комнату.
Попросту говоря, это монитор и клавиатура, причём монитор мог поддерживать цвета.
Сейчас же терминал это программа, &lt;em&gt;эмулирующая&lt;/em&gt; возможности тех, физических терминалов.
Физический современный терминал можно встретить в дата-центрах и серверных.&lt;/p&gt;
&lt;p&gt;Вернёмся к ANSI кодам.
Это текстовые коды, которые интерпретируются терминалом (программой, а не оболочкой) как форматирующие: красящие, подчёркивающие, ожирняющие и т.п.
Когда терминал встречает форматирующий код, то он его не печатает, а лишь применяет форматирование ко всему последующему, например, пишет красным цветом.
Также есть код, который сбрасывает форматирование на обычное.
Подробней можно почитать тут &lt;a class="reference external" href="https://www.lihaoyi.com/post/BuildyourownCommandLinewithANSIescapecodes.html"&gt;lihaoyi.com&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Эмуляторов физических терминалов много, по умолчанию же используется  какой-нибудь популярный, вроде xterm-256color.&lt;/p&gt;
&lt;p&gt;Самая широкая палитра ANSI кодов насчитывает 256 цветов, а также форматирующие модификаторы (жирность, подчёркнутость, фон и т.п.).
Кроме того, коды позволяют перемещать курсор не только в строке ввода, но и во всей области экрана, если эмулятор это поддерживает.
В таких терминалах можно создавать программы с текстовым интерфейсом, как в vim или Midnight Commander.&lt;/p&gt;
&lt;/div&gt;
</content><category term="misc"></category></entry><entry><title>Книги и инструменты для начинающего дизайнера</title><link href="/books-and-tools-for-design-beginners.html" rel="alternate"></link><published>2024-12-10T00:00:00+03:00</published><updated>2025-02-10T00:00:00+03:00</updated><author><name>Степан Захаров</name></author><id>tag:None,2024-12-10:/books-and-tools-for-design-beginners.html</id><summary type="html">&lt;p class="first last"&gt;Подборка материалов для тех, кто начинает заниматься веб-дизайном или дизайном интерфейсов.&lt;/p&gt;
</summary><content type="html">&lt;!-- TODO: Link to article on fonts. --&gt;
&lt;blockquote class="epigraph"&gt;
&lt;p&gt;Я не дизайнер, хотя зарабатывал деньги созданием лендингов.
Я создавал в соло приложения для веба, телефонов и десктопов.
На каком-то этапе требуется задезигнить цифровой продукт: как будет устроена навигация, где какие функции размещены, как всё будет выглядеть.&lt;/p&gt;
&lt;p&gt;Так вот, ниже те материалы и инструменты, о которых я хотел бы знать в начале пути.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class="section" id="section-2"&gt;
&lt;h2&gt;Книжная полка дизайнера-самоучки&lt;/h2&gt;
&lt;img alt="Обложки книг и материалов, упомянутых ниже." src="/images/books-and-tools-for-design-beginners/books.png" style="width: 100%;" /&gt;
&lt;div class="section" id="adam-wathan-and-steve-schoger-refactoring-ui"&gt;
&lt;h3&gt;Adam Wathan and Steve Schoger — Refactoring UI&lt;/h3&gt;
&lt;p&gt;&lt;a class="reference external" href="https://www.refactoringui.com/"&gt;Refactoring UI&lt;/a&gt;  это супер-практичная книга по веб-дизайну.
Идеальный вариант для новичка, которому не терпится начать.
В книге обо всём понемногу: поработав с материалами, вы научитесь дезигнить нормально выглядящие сайты.
Мне нравится структура книги, множество примеров как надо и как не надо, а ещё мне импонируют изложенные принципы.&lt;/p&gt;
&lt;p&gt;Книга особенно понравится не-дизайнерам, например, фронтэндерам.
Я считаю её идеальным вариант для тех, кому потребовалось поработать за дизайнера.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="section-3"&gt;
&lt;h3&gt;Стив Круг — Не заставляй меня думать&lt;/h3&gt;
&lt;p&gt;&lt;a class="reference external" href="https://eksmo.ru/book/ne-zastavlyayte-menya-dumat-3-e-izdanie-ITD826441/"&gt;Не заставляй меня думать&lt;/a&gt; это топ-книга для тех, кто ничего не понимает в интерфейсах.
Здесь вы узнаете, почему как интерфейсы способствуют достижению бизнес-целей сайта или приложения.
И, конечно, как создавать успешные интерфейсы.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="google-google-fonts-knowledge"&gt;
&lt;h3&gt;Google — Google Fonts: Knowledge&lt;/h3&gt;
&lt;p&gt;Существует много материалов по типографике, но &lt;a class="reference external" href="https://fonts.google.com/knowledge/"&gt;Google Fonts: Knowledge&lt;/a&gt; один из самых доступных и классных.
Ликбез по шрифту, который всегда под рукой.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="section-4"&gt;
&lt;h3&gt;Ричард Пулман — Школа дизайна&lt;/h3&gt;
&lt;p&gt;&lt;a class="reference external" href="https://www.mann-ivanov-ferber.ru/catalog/product/shkola-dizajna-shrift/"&gt;Шрифт&lt;/a&gt; и &lt;a class="reference external" href="https://www.mann-ivanov-ferber.ru/catalog/product/shkola-dizajna-maket/"&gt;Макет&lt;/a&gt; это практическое руководство для студентов и дизайнеров-самоучек.
Подразумевается, что изучив их, вы сможете верстать печатное: книги, брошюры, плакаты и т.п.
В общем, хорошая база, но в диджитале свои акценты.&lt;/p&gt;
&lt;p&gt;В классике макета центральное место занимают сетки, составить представление о них можно ещё &lt;a class="reference external" href="https://medium.com/tradecraft-traction/harmonious-typography-and-grids-10da490a17d"&gt;здесь&lt;/a&gt; и &lt;a class="reference external" href="https://github.com/sosolimited/Design-Handbook/wiki/Grid-Systems"&gt;тут&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="section-5"&gt;
&lt;h3&gt;Ещё&lt;/h3&gt;
&lt;p&gt;На сайтах дизайн-студий и дистрибьютеров шрифтов можно позалипать, натренировать насмотренность в шрифтах и почитать статьи.
Например, &lt;a class="reference external" href="https://type.today/"&gt;type.today&lt;/a&gt; и &lt;a class="reference external" href="https://www.paratype.ru/"&gt;студия Паратайп&lt;/a&gt;.
Тут же стоит искать тёмных лошадок среди профессионально-выполненных шрифтов.&lt;/p&gt;
&lt;p&gt;Можно учиться у современных и стройных дизайн-систем: &lt;a class="reference external" href="https://developer.apple.com/design/"&gt;Apple Developer — Design&lt;/a&gt;, &lt;a class="reference external" href="https://m3.material.io/"&gt;Google — Material 3&lt;/a&gt;, &lt;a class="reference external" href="https://developer.microsoft.com/en-us/fluentui/"&gt;Microsoft — Fluent UI&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Поискать вдохновения и тренды можно на &lt;a class="reference external" href="https://dribbble.com"&gt;dribbble.com&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Базу по анимации я подсматривал у &lt;a class="reference external" href="https://uxdesign.cc/the-ultimate-guide-to-proper-use-of-animation-in-ux-10bd98614fa9"&gt;skytskyi&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Напоследок моя слабость, &lt;a class="reference external" href="https://www.mann-ivanov-ferber.ru/catalog/product/iskusstvo-kalligrafii/"&gt;Дэвид Харрис — Искусство каллиграфии&lt;/a&gt;.
Книга вряд ли научит выбирать шрифты, но переполнена эстетикой европейского письма.
Каллиграфия и создание шрифтов для интересующихся, лукбук — для остальных.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="section-6"&gt;
&lt;h2&gt;Инструменты&lt;/h2&gt;
&lt;div class="section" id="section-7"&gt;
&lt;h3&gt;Что я использую&lt;/h3&gt;
&lt;p&gt;Если мне понравился &lt;em&gt;шрифт&lt;/em&gt; на сайте, то я лезу в инструменты разработчика в браузере.
А беру шрифты обычно с &lt;a class="reference external" href="https://fonts.google.com"&gt;Google Fonts&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Мои спасательные круги в мире &lt;em&gt;цвета&lt;/em&gt; это.
&lt;a class="reference external" href="https://uicolors.app/create"&gt;Tailwind CSS Color generator&lt;/a&gt; и &lt;a class="reference external" href="https://coolors.co/"&gt;coolors.co&lt;/a&gt;.
Для текста проверяю контрастность на &lt;a class="reference external" href="https://webaim.org/resources/contrastchecker/"&gt;WebAIM&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Прототипирую дизайн&lt;/em&gt; в &lt;a class="reference external" href="https://www.figma.com/"&gt;Figma&lt;/a&gt;.
Это лучший на рынке кроссплатформенный и бесплатный инструмент для дизайна сайтов и приложений.
Супер удобная.
Вещь.
В Figma много плагинов, но самое ценное для начинающих это официальные тулкиты для дизайна под конкретную платформу (Google, Apple и Microsoft тут).&lt;/p&gt;
&lt;p&gt;Если &lt;em&gt;векторный редактор&lt;/em&gt;, то &lt;a class="reference external" href="https://inkscape.org/"&gt;Inkscape&lt;/a&gt;.
Опенсурс, хорошо работает, да и я привык.
Для программистов ещё один плюс — автоматизация и экспорт в LaTeX.&lt;/p&gt;
&lt;p&gt;За &lt;em&gt;стоковыми фото&lt;/em&gt; хожу на &lt;a class="reference external" href="https://unsplash.com/"&gt;Unspash&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Иконки для сайта&lt;/em&gt; беру из коллекций, чтобы сочетались.
Моя любимая — &lt;a class="reference external" href="https://heroicons.com/"&gt;heroicons&lt;/a&gt;, она для интерфейсов.
Чего не хватает, беру на &lt;a class="reference external" href="https://simpleicons.org/"&gt;simpleicons&lt;/a&gt; (обычно иконки соцсетей).
Также удобно использовать &lt;em&gt;иконочные шрифты&lt;/em&gt;, например, &lt;a class="reference external" href="https://fonts.google.com/icons"&gt;Material Icons&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="section-8"&gt;
&lt;h3&gt;Что я не использую&lt;/h3&gt;
&lt;p&gt;&lt;em&gt;Type scaler.&lt;/em&gt;
Он строит сетку размеров для шрифта на каком-то отношении (например, 1.2).
В конечном итоге вы приходите к дробным значениям, а они не кроссплатформенны (системы по-разному их округлят, и будет по-разному выглядеть).
Надёжнее взять готовую сетку из целых чисел.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Сетки для макетов&lt;/em&gt; в диджитале.
Тут много за и против, я сетки не люблю.
Мне нравится подход из Refactoring UI: отталкиваемся от контента (feature first), берём хороший отступ, и следим за шириной.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
</content><category term="misc"></category></entry><entry><title>Kebab-case лучший</title><link href="/note-on-kebab-case.html" rel="alternate"></link><published>2024-11-06T00:00:00+03:00</published><updated>2025-02-09T00:00:00+03:00</updated><author><name>Степан Захаров</name></author><id>tag:None,2024-11-06:/note-on-kebab-case.html</id><summary type="html">&lt;p class="first last"&gt;Сравниваем разные case, и выбираем kebab. Почему kebab-case лучше остальных написаний.&lt;/p&gt;
</summary><content type="html">&lt;blockquote class="epigraph"&gt;
Мой выбор — kebab-case!
Заметка для тех, кто много работает в терминале.&lt;/blockquote&gt;
&lt;p&gt;В терминале неудобно работать с именами файлов, содержащие пробел.
Например, команда&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="go"&gt;head 005 kebab case.tex&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;применяется не к одному файлу, а к трём: &lt;code&gt;005&lt;/code&gt;, &lt;code&gt;kebab&lt;/code&gt; и &lt;code&gt;case.tex&lt;/code&gt;.
Дело в том, что пробел используется командной оболочкой как разделитель аргументов.
Из-за этого пробелы в именах файлов приходится экранировать или заключать в кавычки.&lt;/p&gt;
&lt;p&gt;Чтобы не возиться с кавычками и экранированием, я встречал три соглашения для имён файлов: snake_case, kebab-case и PascalCase.
Вот они, слева направо.&lt;/p&gt;
&lt;table border="1" class="docutils align-center"&gt;
&lt;colgroup&gt;
&lt;col width="31%" /&gt;
&lt;col width="35%" /&gt;
&lt;col width="35%" /&gt;
&lt;/colgroup&gt;
&lt;thead valign="bottom"&gt;
&lt;tr&gt;&lt;th class="head"&gt;Pascal&lt;/th&gt;
&lt;th class="head"&gt;Snake&lt;/th&gt;
&lt;th class="head"&gt;Kebab&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td&gt;005KebabCase.pdf&lt;/td&gt;
&lt;td&gt;005_kebab_case.pdf&lt;/td&gt;
&lt;td&gt;005-kebab-case.pdf&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;IvanovCVMLEngineer.pdf&lt;/td&gt;
&lt;td&gt;ivanov_cv_ml_engineer.pdf&lt;/td&gt;
&lt;td&gt;ivanov-cv-ml-engineer.pdf&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;ОтпускШаблон.docx&lt;/td&gt;
&lt;td&gt;отпуск_шаблон.docx&lt;/td&gt;
&lt;td&gt;отпуск-шаблон.docx&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;UnitsInLastPlace.md&lt;/td&gt;
&lt;td&gt;units_in_last_place.md&lt;/td&gt;
&lt;td&gt;units-in-last-place.md&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Конечно, при выборе соглашения стоит прежде всего придерживаться традиции проекта, учитывать технические ограничения и стандарты платформы.
Но если выбор можно сделать в пользу kebab-case, я его предпочту остальным.
И вот почему.&lt;/p&gt;
&lt;div class="section" id="pascalcase"&gt;
&lt;h2&gt;Почему не PascalCase?&lt;/h2&gt;
&lt;p&gt;PascalCase вовсе НеИмитируетПробелы, и европейский глаз к такому не подготовлен.
Кроме того, у чисел нет строчной и заглавной форм, в отличие от букв.
В целом, парсинг имён файлов усложняется, а ещё и Shift зажимать.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="snake-case"&gt;
&lt;h2&gt;Почему не snake_case?&lt;/h2&gt;
&lt;p&gt;Snake_case имитирует пробелы, но в стандартных моноширинных шрифтах нижнее подчёркивание обычно смотрится крупно.
Судите сами.&lt;/p&gt;
&lt;div class="figure align-center"&gt;
&lt;img alt="" src="/images/kebab-case/underscore-test.webp" style="width: 512px;" /&gt;
&lt;p class="caption"&gt;Snake и kebab case в разных шрифтах.&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;На мой взгляд, только у Roboto Mono удачная читаемость в случае snake_case.
И я думаю вот почему.
Во времена пишущих машинок нижнее подчёркивание использовалось для выделения текста или для мест под пропуски в бланках.
С такими задачами символ подчёркивания должен был быть чуть шире большинства символов и ниже базовой линии.
Ну а современные шрифты чтут эту традицию.
Разумно?&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="kebab-case-1"&gt;
&lt;h2&gt;Почему kebab-case?&lt;/h2&gt;
&lt;p&gt;А вот у kebab-case нет упомянутых недостатков.
Его единственный недостаток состоит в ограничениях или неудобствах при программировании, особенно, при импорте исходного файла.
Минус/дефис используется как оператор вычитания и, в лучшем случае, синтаксис языка позволяет как-то его экранировать.&lt;/p&gt;
&lt;p&gt;Недостатки других соглашений для меня существенней, поэтому kebab-case лучший.&lt;/p&gt;
&lt;/div&gt;
</content><category term="misc"></category></entry><entry><title>Zotero</title><link href="/zotero.html" rel="alternate"></link><published>2024-10-30T00:00:00+03:00</published><updated>2025-02-09T00:00:00+03:00</updated><author><name>Степан Захаров</name></author><id>tag:None,2024-10-30:/zotero.html</id><summary type="html">&lt;p class="first last"&gt;Пост про классную программу-медиатеку, помощника в исследованиях и документации. С Zotero у вас +100 чтобы не потерять документы для работы или хобби.&lt;/p&gt;
</summary><content type="html">&lt;blockquote class="epigraph"&gt;
Я использую &lt;a class="reference external" href="https://www.zotero.org/"&gt;Zotero&lt;/a&gt; как помощника в исследованиях и документации.
Он помогает не потерять научные статьи, книги, лекции, блоги, программы, презы с митингов или отчёты коллег.
Zotero для меня это медиатека и браузерные закладки на стероидах.&lt;/blockquote&gt;
&lt;div class="figure align-center"&gt;
&lt;img alt="" src="/images/zotero/zotero-screenshot.png" /&gt;
&lt;p class="caption"&gt;Zotero с домашней медиатекой и открытой карточкой &lt;a class="reference external" href="https://search.rsl.ru/ru/record/01012442080"&gt;моего диссера&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="section-1"&gt;
&lt;h2&gt;Ваши файлы всегда с вами&lt;/h2&gt;
&lt;p&gt;Медиатека хранится отдельно от Zotero, ваши файлы всегда с вами.
Физически это просто папка с файлами, которую вы можете перетащить на другой комп или бэкапнуть.&lt;/p&gt;
&lt;p&gt;Медиатека в Zotero состоит из карточек о материале (название, авторы и т.п., метаданные), к каждой карточке можно прикрепить файл с материалом и что захотите.
Кликая на карточку, открывается вложенный файл, например, книга.
Даже когда вложений несколько, открывается нужное.&lt;/p&gt;
&lt;p&gt;Карточек около 30 видов, под все случаи жизни: здесь книги, научные и не научные статьи, судебные дела, датасеты, фильмы, письма и т.п.
Карточки можно объединять в группы, я объединяю по разделу наук или рабочей задаче.
При этом одна карточка может быть сразу в нескольких группах.&lt;/p&gt;
&lt;p&gt;Коллекцию можно пополнить простым перетаскиванием, по идентификатору (например, ISBN или DOI) или прямо из браузера.
При этом многое автоматизировано: когда вы добавляете pdf-ку, то формируется карточка, а когда добавляете по идентификатору, то скачается файл из открытых источников.
Круто же.&lt;/p&gt;
&lt;p&gt;В Zotero есть облачная синхронизация, можно настроить своё облако или заплатить создателям (300 Мб бесплатно).
Встроенное облако работает адекватно, без танцев с бубнами.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="section-2"&gt;
&lt;h2&gt;Библиография&lt;/h2&gt;
&lt;p&gt;Библиографию можно выгрузить разными способами и в разных библиографических стилях.
Я выгружаю текстом, в буфер обмена или в &lt;a class="reference external" href="https://ctan.org/pkg/biblatex"&gt;BibLaTeX&lt;/a&gt;.
Пользователей Word-а не обидели: у Zotero есть плагин для библиографии и кросс-ссылок.&lt;/p&gt;
&lt;p&gt;Обычно менеджер библиографии работает хорошо.
Для пользователей LaTeX оставили настройки для названий bib entries.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="pdf"&gt;
&lt;h2&gt;PDF читалка&lt;/h2&gt;
&lt;p&gt;В Zotero встроена читалка pdf, и она хороша: быстрая, есть аннотации разных видов и тёмная тема для чтения ночью.
Если вас читалка не устраивает, вы можете выбрать в настройках свою.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="section-3"&gt;
&lt;h2&gt;Заметки&lt;/h2&gt;
&lt;p&gt;Есть встроенные заметки, они крепятся прямо к карточке.
Можно набирать любой текст и уравнения.&lt;/p&gt;
&lt;p&gt;Но я всё-таки предпочитаю их &lt;a class="reference external" href="https://obsidian.md/"&gt;Obsidian&lt;/a&gt;-у или полноценным конспектам в TeX-e (&lt;a class="reference external" href="https://ctan.org/pkg/latexmk"&gt;latexmk&lt;/a&gt; ой как упрощает жизнь с техом).&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="section-4"&gt;
&lt;h2&gt;Напоследок&lt;/h2&gt;
&lt;p&gt;Zotero надёжный, проекту 18 лет.
Проект активный, в 2024 году, например, вышла крупная переработка интерфейса, теперь он выглядет современно.
У Zotero открытый &lt;a class="reference external" href="https://github.com/zotero"&gt;исходный код&lt;/a&gt;, +100 к доверию.
Zotero кроссплатформенный, я работал с ним на MacOS, Ubuntu и Windows 10, всё было отлично.
А ещё Zotero бесплатный, и это вообще вау; создатели зарабатывают на подписках к облаку.&lt;/p&gt;
&lt;p&gt;В общем, рекомендую всем инженерам, людям науки, студентам, школьникам, вольным слушателям и тем, кто много работает с документацией.
Суперская программа.&lt;/p&gt;
&lt;/div&gt;
</content><category term="misc"></category></entry><entry><title>Когда Ctrl-Z не хватает</title><link href="/when-ctrl-z-is-not-enough.html" rel="alternate"></link><published>2024-10-22T00:00:00+03:00</published><updated>2025-02-09T00:00:00+03:00</updated><author><name>Степан Захаров</name></author><id>tag:None,2024-10-22:/when-ctrl-z-is-not-enough.html</id><summary type="html">&lt;p class="first last"&gt;Как вносить правки так, чтобы можно было откатить их часть. Несколько простых решений и профессиональные инструменты.&lt;/p&gt;
</summary><content type="html">&lt;blockquote class="epigraph"&gt;
&lt;p&gt;Ситуация.
Вы готовите презентацию, пишете отчёт или код, дизайните обложку, в общем, работаете над проектом не одного дня.
В какой-то момент требуется доработка: заказчик попросил, пользователь обнаружил баг или начальнику что-то не понравилось.
Вы вносите правки, отправляете на проверку, и получаете ответ наподобие «это оставь, а то верни, как было».&lt;/p&gt;
&lt;p&gt;Как откатить часть изменений?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class="section" id="section-1"&gt;
&lt;h2&gt;Решение 1. Завести директорию для версий.&lt;/h2&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;Заводите директорию под архив предыдущих версий.&lt;/li&gt;
&lt;li&gt;Когда правки накопились, копируете текущую версию в архив и даёте ей номер.&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="figure align-center"&gt;
&lt;img alt="" src="/images/ctrl-z/dir.png" style="width: 384px;" /&gt;
&lt;p class="caption"&gt;Решение 1. Директория с версиями файла.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="section-2"&gt;
&lt;h2&gt;Решение 2. Особенное имя для текущей версии.&lt;/h2&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;Одна директория под все версии, включая текущую.&lt;/li&gt;
&lt;li&gt;Имя текущей версии начинаете с нижнего подчёркивания («_презентация.pptx»).
Так она сортируется первой в списке файлов.&lt;ul&gt;
&lt;li&gt;Если файловый проводник сортирует файлы иначе, начните имя текущей версии по-другом, например, с «A» или «0».&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Когда правки накопились, копируете текущую версию и переименовываете подобно прошлым.&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="figure align-center"&gt;
&lt;img alt="" src="/images/ctrl-z/name.png" style="width: 384px;" /&gt;
&lt;p class="caption"&gt;Решение 2. Особенное имя для текущей версии, чтобы она всегда была под рукой.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="section-3"&gt;
&lt;h2&gt;Решение 3. Символьная ссылка.&lt;/h2&gt;
&lt;p&gt;Вы действуете как в Решении 2, но поддерживаете ссылку на текущую версию.
Особенно удобно при работе из командной оболочки.&lt;/p&gt;
&lt;div class="figure align-center"&gt;
&lt;img alt="" src="/images/ctrl-z/name.png" style="width: 384px;" /&gt;
&lt;p class="caption"&gt;Решение 3. Символьная ссылка на текущую версию.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="section-4"&gt;
&lt;h2&gt;Дальнейшие усовершенстовования&lt;/h2&gt;
&lt;div class="section" id="section-5"&gt;
&lt;h3&gt;Решение 4. Система контроля версий.&lt;/h3&gt;
&lt;p&gt;Погромисты придумали автоматический инструмент, называемый «системой контроля версий».
Это программа, которая следит за изменениями в файлах проекта и позволяет их сохранять в историю.
Затем вы можете просматривать историю, отслеживать изменения и автоматически получать их список в формате «было-стало».
Вообще, такая система незаменима для проектов, над которыми работают несколько людей.&lt;/p&gt;
&lt;p&gt;Самая популярная система контроля версий сейчас (2025) это &lt;a class="reference external" href="https://git-scm.com/"&gt;Git&lt;/a&gt;.
Но некоторые проекты используют &lt;a class="reference external" href="https://subversion.apache.org/"&gt;Subversion&lt;/a&gt; и &lt;a class="reference external" href="https://www.mercurial-scm.org/"&gt;Mercurial&lt;/a&gt;.
Если вы не работаете в консоли, посмотрите на &lt;a class="reference external" href="https://git-scm.com/downloads/guis"&gt;оконные морды для гита&lt;/a&gt;, они удобны.
Из оконных морд я пользовался только Sublime Merge.&lt;/p&gt;
&lt;p&gt;Ещё я бы отметил систему &lt;a class="reference external" href="https://www.fossil-scm.org/"&gt;Fossil&lt;/a&gt;.
В ней, помимо контроля версий, встроена возможность развернуть свой мини-гитхаб с форумом, вики и прочим.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="section-6"&gt;
&lt;h3&gt;Семантическое версионирование&lt;/h3&gt;
&lt;p&gt;Версионирование это набор принципов, по которым вы решаете «что такое версия, а что нет».
А ещё версионирование решает, как версии продукта именовать.
В идеале, версия файла вам должна сообщить масштаб изменений, и стоит ли она вашего внимания.
Простейший пример — номер издания книги.&lt;/p&gt;
&lt;p&gt;Пожалуй, самый компактный и гуманистический набор правил это &lt;a class="reference external" href="https://semver.org/"&gt;semantic versioning&lt;/a&gt;.
Он создавался под программное обеспечение, но идеи хороши и для других продуктов.
Я бы сформулировал единственный принцип так.&lt;/p&gt;
&lt;blockquote&gt;
&lt;em&gt;Изменения в продукте бывают разных категорий и значимости.
Название версии продукта должно это отражать.&lt;/em&gt;&lt;/blockquote&gt;
&lt;p&gt;Версионирование необходимо более-менее крупным проектам.
А при разработке программного обеспечения оно помогает избежать «ада зависимостей» — ситуации, когда обновление какой-то части может поломать работу других.&lt;/p&gt;
&lt;div class="section" id="section-7"&gt;
&lt;h4&gt;Пример про презентации&lt;/h4&gt;
&lt;p&gt;В презентации могут быть исправления смысловых ошибок, опечаток и визуала.
Исправление смысловой ошибки гораздо серьёзней и важнее остальных: если не исправить eё, нас не так поймут (мы обманем).
А вот в остальных случаях мы отделаемся косыми взглядами.&lt;/p&gt;
&lt;p&gt;Следуя идее выше, система версий для презентаций может быть устроена так.
Для названия используем два числа А и Б, а полным названием версии будет А.Б, например, 1.2.
Число А будет отвечать за серьёзные изменения (устранение семантической ошибки, новый контент), а число Б за мелкие исправления контента и визуала.&lt;/p&gt;
&lt;p&gt;Представьте теперь, что вы читали версию 1.0.
Потом видите свежую, 1.5, и думаете: «Окей, тут наисправляли недочёты, я их видел(а) в 1.0, не буду тратить время».
Ещё через неделю видите 2.3 и уже думаете иначе: «Ага... Тут уже много чего исправили. Надо бы освежить, ведь я знаком(а) только с 1.0».&lt;/p&gt;
&lt;p&gt;Как-то так это должно работать.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="section-8"&gt;
&lt;h3&gt;Список изменений&lt;/h3&gt;
&lt;img alt="" src="/images/ctrl-z/release-notes-pelican.png" style="width: 100%;" /&gt;
&lt;p&gt;В хороших книгах есть предисловие к каждому изданию.
Прочитав предисловия, вы можете понять, какие разделы появились раньше (изначальная цель авторов), много ли было исправлений (как часто авторы и редколлегия ошибаются), ну и почему книга распухла до 700 страниц.&lt;/p&gt;
&lt;p&gt;Так, правило хорошего тона — поддерживать список изменений в проекте, будь-то годовой отчёт или программный продукт.
Список изменений служит читателю: заказчику, коллеге, вам.
С его помощью понятно, что именно изменилось с предыдущей версии.&lt;/p&gt;
&lt;p&gt;Я считаю, что для софта список изменений (changelog на погромистском) необходим: будь-то внутренний проект или опенсурс.
Хороший шаблон списка изменений вот этот — &lt;a class="reference external" href="https://keepachangelog.com/"&gt;keep a changelog&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Для продуктов типа презентаций или отчётов (один документ) я оставляю список изменений где-то в начале, прям внутри документа.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
</content><category term="misc"></category></entry><entry><title>Как именовать файлы, чтобы было удобно</title><link href="/note-on-filenames.html" rel="alternate"></link><published>2024-10-09T00:00:00+03:00</published><updated>2025-02-10T00:00:00+03:00</updated><author><name>Степан Захаров</name></author><id>tag:None,2024-10-09:/note-on-filenames.html</id><summary type="html">&lt;p class="first last"&gt;Как я именую файлы, чтобы было попроще жить. Имена для фотографий, заметок, презентаций, публикаций и книг.&lt;/p&gt;
</summary><content type="html">&lt;div class="section" id="section-2"&gt;
&lt;h2&gt;Имена файлов для фотографий&lt;/h2&gt;
&lt;p&gt;Я ежегодно выгружаю фото из облака на жёсткий диск.
Для названия фото я использую дату, время с точностью до минуты и порядковый номер внутри минуты:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;ГГГГ-ММ-ДД чч-мм ННН[ особенность],
2023-04-23 16-50 000 гора такая-то.jpeg.
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Обычно этого хватает, чтобы быстро найти нужные фотки.
Что ещё даёт формат выше, и почему он такой?&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Бесплатная сортировка по дате и времени: в файловом менеджере всё расположится хронологически.&lt;/li&gt;
&lt;li&gt;Привычное двоеточие для разделения часов и минут непереносимо между операционными системами, поэтому использован дефис (16-50 vs 16:50).&lt;/li&gt;
&lt;li&gt;Номер &lt;code&gt;ННН&lt;/code&gt; нужен для фото в течение одной и той же минуты.
Вместо номера можно писать секунду и миллисекунду, но как по мне, это избыточно и плохо смотрится.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Особенность&lt;/code&gt; я обычно использую для фото, «изолированным» во времени.
Это короткая фраза, чтобы понять, что на фотографии происходит.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Фото я обычно объединяю в директории по годам, а внутри неё некоторые фото объединияю по событию (поездка, праздник и т.п.), указывая хотя бы год:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;ГГГГ  и  ГГГГ[-ММ[-ДД]]-событие.
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Внутри директорий фото по-прежнему названы в формате как выше.
Что делать с новогодними, я пока не решил 🙂&lt;/p&gt;
&lt;div class="section" id="section-3"&gt;
&lt;h3&gt;Как быстро переименовать сотни фоток&lt;/h3&gt;
&lt;p&gt;Для быстрого переименования фотографий и видео есть классная утилита — &lt;a class="reference external" href="https://exiftool.org/"&gt;exiftool&lt;/a&gt;.
Это консольная программа, которая умеет читать метаданные фотографии (EXIF) и позволяет переименовать файлы.
Поддерживает множество форматов.
Так я переименовываю jpeg-и.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="go"&gt;mkdir copy&lt;/span&gt;
&lt;span class="go"&gt;exiftool -o copy -P -d &amp;#39;%Y-%m-%d %H-%M %%03.c.%%e&amp;#39; &amp;#39;-filename&amp;lt;CreateDate&amp;#39; *.jpeg&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;И так переименовываю mov-ы.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="go"&gt;mkdir copy&lt;/span&gt;
&lt;span class="go"&gt;exiftool -o copy -P -d &amp;#39;%Y-%m-%d %H-%M %%03.c.%%e&amp;#39; &amp;#39;-filename&amp;lt;CreationDate&amp;#39; *.mov&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Команды отличаются только выбором метаданных: с моего телефона временная метка о создании фотки лежит в &lt;code&gt;CreateDate&lt;/code&gt;, а о видео в &lt;code&gt;CreationDate&lt;/code&gt;.
Всё остальное одинаковое:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;code&gt;-o copy&lt;/code&gt; предписывает создать копии, чтобы не похерить оригиналы в случае чего;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-P&lt;/code&gt; предписывает сохранить все метаданные исходников, так мы действительно лишь переименовываем файлы;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-d 'fmt'&lt;/code&gt; это формат имени файла;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-filename&amp;lt;tag&lt;/code&gt; указывает из каких меток дёргать информацию для переименования.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;На сайте exiftool множество примеров, а документация вполне себе.
Вероятно, существует и оконная морда для утилиты, но мне ОК работать из-под консоли.&lt;/p&gt;
&lt;p&gt;Чтобы понять, какие метки хранит ваша фотка, подходит команда:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="go"&gt;exiftool &amp;#39;Screenshot 2024-12-03 at 21.15.06.png&amp;#39;&lt;/span&gt;

&lt;span class="go"&gt;ExifTool Version Number         : 13.03&lt;/span&gt;
&lt;span class="go"&gt;File Name                       : Screenshot 2024-12-03 at 21.15.06.png&lt;/span&gt;
&lt;span class="go"&gt;Directory                       : .&lt;/span&gt;
&lt;span class="go"&gt;File Size                       : 584 kB&lt;/span&gt;
&lt;span class="go"&gt;File Modification Date/Time     : 2024:12:03 21:15:13+03:00&lt;/span&gt;
&lt;span class="go"&gt;File Access Date/Time           : 2025:01:26 14:44:23+03:00&lt;/span&gt;
&lt;span class="go"&gt;File Inode Change Date/Time     : 2024:12:03 21:15:13+03:00&lt;/span&gt;
&lt;span class="go"&gt;...&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Чтобы всё выше работало, нужны оригиналы файлов.
Добросовестные соцсети и месенджеры метаданные трут, и правильно делают.
А ещё они сжимают файлы.
Короче, для личных альбомов просите у близких оригиналы («отправить как документ»).&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="section-4"&gt;
&lt;h2&gt;Имена для заметок и задач&lt;/h2&gt;
&lt;p&gt;Имя заметки удобно начинать с даты:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;ГГГГ-ММ-ДД название,
2024-07-13 созвон с Иван Иванычем,
2024-07-14-python-orm-review.
&lt;/pre&gt;&lt;/div&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Для ежедневной заметки имя лучше и не придумаешь.&lt;/li&gt;
&lt;li&gt;Удобно для проектов на работе.
Заводите директорию с таким именем, а датой выбираете начало выполнения.&lt;/li&gt;
&lt;li&gt;Если вы работаете из-под консоли, то смело заменяйте пробелы в на то, что предпочитаете (я за kebab-case, &lt;a class="reference external" href="/note-on-kebab-case.html"&gt;вот почему&lt;/a&gt;).&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="section-5"&gt;
&lt;h2&gt;Формат даты, который я использую&lt;/h2&gt;
&lt;p&gt;В именах файлов выше использован один и тот же формат даты, &lt;a class="reference external" href="https://ru.wikipedia.org/wiki/ISO_8601"&gt;ISO 8601&lt;/a&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;ГГГГ-ММ-ДД,
2024-10-09  →  9 октября 2024-го года.
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Почему он?&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Дату без разделителя тяжело читать (20241009).&lt;/li&gt;
&lt;li&gt;Файлы с именами, начинающимися как выше, «бесплатно» отсортированы по дате (лексиграфический порядок): что в файловых менеджерах, что при написании скриптов.&lt;/li&gt;
&lt;li&gt;Привычный жителю России разделитель «точка» конфликтует с разделителем для типа файла (2024.10.09.png).&lt;/li&gt;
&lt;li&gt;ISO 8601 — международный стандарт, поэтому велика вероятность, что та или иная программа его распознает.&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="section-6"&gt;
&lt;h2&gt;Имена файлов для книг, статей и публикаций вообще&lt;/h2&gt;
&lt;p&gt;У меня много литературы в электронном виде, и я стараюсь использовать &lt;a class="reference external" href="/zotero.html"&gt;Zotero&lt;/a&gt; как библиотеку (инфотеку).
Но без него, я не нашёл способа именовать книги или статьи лучше, чем так&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;фамилия - год - часть названия,
фамилия и фамилия - год - часть названия,
фамилия и др. - год - часть названия.
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Т.е. указывать фамилии авторов, год публикации и часть названия.
Например,&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Головаль - 2024 - LaTeX в 2024 году.pdf,
Voskov and Tchelepi - 2012 - Comparison of nonlinear formulations.pdf,
Григорьев и др. - 2017 - Обзор работ по теории фильтрации.pdf.
&lt;/pre&gt;&lt;/div&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Мне проще ориентироваться по фамилиям авторов, поэтому они в начале.&lt;/li&gt;
&lt;li&gt;Двух или трёх авторов могу написать целиком, а при большем числе авторов оставляю фамилию только первого («фамилия и др.»)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;В том же формате я сохраняю презентации с митингов или ноутбуки коллег, но указываю год и месяц:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Иванова - 2024-09 - Как пользоваться докером.pdf,
Petrov - 2024-08 - Linear algebra in numpy.ipynb.
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Сам же презентации и ноутбуки обычно дублирую в pdf — это кроссплатформенно, не возникает проблем с шрифтами, ничего не едет.
А в случае ноутбука — коллеге не придётся его запускать, чтобы увидеть результаты, ну и с телефона сможет прочесть.&lt;/p&gt;
&lt;/div&gt;
</content><category term="misc"></category></entry></feed>