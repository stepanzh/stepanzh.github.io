Сердце языка Julia — множественная диспетчеризация
##################################################

:date: 2025-05-13
:slug: julia-multiple-dispatch
:summary: Ву-ху. Первый пост про язык Julia, и сразу в сердце... Рассказываю про core design фичу — multiple dispatch. Примеры, что это такое и как работает. По полочкам! А в послесловии дружеский подзатыльник Пайтону.
:description: Рассказываю про core design фичу — multiple dispatch. Примеры, что это такое и как работает. По полочкам! А в послесловии дружеский подзатыльник Пайтону.
:keywords: julia,multiple dispatch,язык программирования,type system,система типов

.. _телеге: https://t.me/stepanzh_blog/
.. _финансово поддержать: {filename}/pages/support-me.rst


.. epigraph:: 

   Ву-ху. Первый пост про язык Julia, и сразу в сердце...
   Рассказываю про core design фичу — multiple dispatch.
   Примеры, что это такое и как работает.
   По полочкам!
   А в послесловии дружеский подзатыльник Пайтону.


Система типов в Julia
---------------------

Чтобы понять, как устроена диспетчеризация в Julia, надо познакомиться с системой типов.

.. 

  В Julia типы организованы в иерархию типа дерево.

.. code-block:: text

  Any
  └─ Number
     ├─ Complex
     │  ├─ Complex{Int64}
     │  ├─ Complex{Float64}
     │  └─ ...
     └─ Real
        ├─ AbstractFloat
        │  ├─ BigFloat
        │  ├─ Float16
        │  ├─ Float32
        │  └─ Float64
        ├─ ...
        ├─ Integer
        │  ├─ Bool
        │  ├─ Signed
        │  │  ├─ BigInt
        │  │  ├─ Int128
        │  │  ├─ Int16
        │  │  ├─ Int32
        │  │  ├─ Int64
        │  │  └─ Int8
        │  └─ Unsigned
        │     ├─ UInt128
        │     ├─ UInt16
        │     ├─ UInt32
        │     ├─ UInt64
        │     └─ UInt8
        └─ Rational
           ├─ Rational{Int32}
           ├─ Rational{Int64}
           └─ ...

Это часть дерева типов, она содержит (почти) все типы для чисел «из коробки».
Например, цепочка от :code:`Int64` до :code:`Any` такая.

.. code-block:: julia-repl

  julia> Int64 <: Signed <: Integer <: Real <: Number <: Any
  true

Корень дерева это тип :code:`Any`.
А все типы в дереве делятся на два вида: абстрактный (abstract) или конкретный (concrete).

Про конкретные типы компилятору известно всё, включая их устройство в памяти.
С ними можно считать в рантайме.
И они являются листьями в дереве типов.

Абстрактные типы используются для упорядочивания типов в дерево.
Отношение между типами выстраивается как «является подтипом такого-то типа», но Julia не объектно-ориентированный язык, здесь нет привычного для ООП наследования (inheritance).
Например, нельзя со 100% уверенностью написать функцию для чисел :code:`Number` и быть уверенным, что она будет работать для каждого подтипа.

Однако, создавать функции для абстрактных типов данных можно и полезно.
На этом строится поддержка обобщённой (generic) парадигмы.
Когда компилятор встречает вызов такой функции, он проверяет, все ли есть, чтобы её выполнить для конкретных аргументов.
Если чего-то не хватает, увы, ошибка.
А если всё есть, то компилятор создаёт настолько оптимизированный код, насколько может.


Диспетчеризация
---------------

Я начну с примера.
В языке Julia можно так.

.. code-block:: julia-repl
  :linenos: table

  julia> f(x, y) = "default";

  julia> f(x::T, y::T) where {T} = "default when x and y have same type";

  julia> f(x::Int, y::Int) = "x is Int, y is Int";

  julia> f(x::Int, y::Float64) = "x is Int, y is Float64";
  
  julia> f(x, y, z) = "oh my, there are x, y and even z!";

  julia> f("a", 1)
  "default"

  julia> f("a", "b")
  "default when x and y have same type"

  julia> f(1, 2)
  "x is Int, y is Int"

  julia> f(1, 2.0)
  "x is Int, y is Float64"

  julia> f(1, 2, 3)
  "oh my, there are x, y and even z!"

Выше определена одна функция :code:`f`.

.. code-block:: julia-repl

  julia> f
  f (generic function with 5 methods)

И пять методов для неё.

.. code-block:: julia-repl

  julia> methods(f)
   [1] f(x::Int64, y::Float64)
   [2] f(x::Int64, y::Int64)
   [3] f(x, y, z)
   [4] f(x::T, y::T) where T
   [5] f(x, y)

.. 

  Julia не объектно-ориентированный язык: здесь *методы принадлежат не объектам, а функциям*.

Когда функция вызывается, то диспетчер просматривает, какие есть методы у функции и выбирает тот, который лучшим образом подходит.
«Выбрать лучшим образом» значит выбрать метод, типы аргументов которого наиболее «близки» к типам передаваемых аргументов.
В случае вызова :code:`f(1, 2)` подходят сразу три метода:

- :code:`f(x, y)`,
- :code:`f(x::T, y::T) where {T}`,
- :code:`f(x::Int64, y::Int64)`.

Но вызывается последний, потому что типы аргументов (числа 1 и 2) наиболее близки к :code:`Int64` и :code:`Int64` (вообще, они совпадают с ними). 
Я вернусь к этому вопросу позднее.

.. 

  Итак, диспетчеризация это процесс выбора метода для конкретного вызова функции.

А что значит «множественная диспетчеризация» (multiple dispatch)?

.. 

  Множественная диспетчеризация это вид диспетчеризации, который учитывает типы *нескольких аргументов*.

В случае Julia учитываются типы всех *позиционных аргументов* (positional arguments), а вот диспетчеризацию для аргументов по ключу (keyword arguments) не завезли.

Что ещё можно почерпнуть из примеров выше?
==========================================

Декларация не нужна
~~~~~~~~~~~~~~~~~~~

Не обязательно декларировать тип(ы) аргументов функции.

.. code-block:: julia-repl

  julia> f(x, y) = "default";

На самом деле, декларация здесь есть, но неявная.
Этот пример эквивалентен такому.

.. code-block:: julia-repl

  julia> f(x::Any, y::Any) = "default";

Тип :code:`Any` особый, он «прародитель» всех других.
На самом деле, в Julia нет привычного для ООП наследования (inheritance).
Поэтому нет и родительских отношений между типами.

Однако, типы организованы иерархически, в виде дерева.
Корнем этого дерева является тип :code:`Any`.
А все остальные с ним связаны: опосредованно или напрямую.

Диспатч на абстрактных типах
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Можно диспетчеризовываться не только на конкретных, но и на абстрактных типах.

.. code-block:: julia-repl

   julia> f(x, y) = "default";

   julia> f(x::Int, y::Int) = "x is Int, y is Int";

   julia> f(x::Real, y::Real) = "x and y are real numbers";

(Последний пример для наглядности, тип :code:`Real` служит для представления всех действительных чисел.)

Абстрактные типы (abstract types), например, :code:`Any` и :code:`Real`, используются только для построения дерева типов.
Они несут только семантику.
А вот про конкретные типы (сoncrete types) компилятору всё известно, включая то, как они представлены в памяти (memory layout).
Они представляют реально существующие в памяти объекты, имеющие значения (value).

Диспатч на количестве аргументов
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Методы могут иметь разное количество аргументов, а диспетчеризация это учитывает.

.. code-block:: julia-repl

  julia> f(x, y) = "default";

  julia> f(x, y, z) = "oh my, there are x, y and even z!";

Generic programming included
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Julia поддерживает обобщённую (generic) парадигму.

.. code-block:: julia-repl

  julia> f(x::T, y::T) where {T} = "default when x and y have same type";

Здесь в одной строчке определяется семейство методов, у которых два аргумента, имеющих одинаковый тип (и он назван :code:`T`).

Кстати, тип аргументов доступен как в рантайме (runtime) так и во время компиляции (compile time).

.. code-block:: julia-repl

  julia> atruntime(x) = typeof(x);

  julia> atcompiletime(x::T) where {T} = T;

  julia> atruntime(π)
  Irrational{:π}

  julia> atcompiletime(π)
  Irrational{:π}

У Julia из коробки just-in-time компиляция.
Знать типы во время компиляции бывает необходимо, чтобы дешёво извлечь информацию об аргументах.
Например, так можно узнать размерность массива :code:`ndims(x)` или тип его элементов :code:`eltype(x)`.

Как выбирается метод?
---------------------

Пример попроще
==============

Пусть у нас есть функция с одним аргументом и несколькими методами.

1. :code:`g(x)`
2. :code:`g(x::Number)`
3. :code:`g(x::Float64)`

Если вызвать функцию от целого числа :code:`g(1)`, то применится второй метод :code:`g(::Number)`.
Логика следующая.

- Подходят два метода: :code:`g(::Any)` и :code:`g(::Number)`.
- Тип :code:`Number` в дереве ближе к :code:`Int64`, чем :code:`Any` к :code:`Int64`.
  Можно также сказать, что :code:`Number` более близок к конкретным типам, чем :code:`Any`.
- Поэтому берём его.

Пример посложнее
================

А что если аргументов несколько?

.. code-block:: julia-repl

  julia> f(x, y) = "default";

  julia> f(x::Number, y::Number) = "Number & Number";

  julia> f(x::Int, y::Number) = "Int & Number";

  julia> f(1, "a")
  "default"

  julia> f(1, 2)
  "Int & Number"

  julia> f(1, 1.5)
  "Int & Number"

  julia> f(1.5, 1.5)
  "Number & Number"

Здесь у функции три метода.

С первым вызовом :code:`f(1, "a")` всё понятно, второй аргумент это строка, и только один метод подходит из трёх.

Для оставшихся случаев давайте обратимся к дереву типов.
Я намеренно оставил только те типы, которые участвуют в оставшихся случаях: :code:`Any`, :code:`Number`, :code:`Int64` (он же :code:`Int`) и :code:`Float64`.

.. code-block:: text

  Any
  └─ Number
     └─ Real
        ├─ AbstractFloat
        │  └─ Float64
        └─ Integer
           └─ Signed
              └─ Int64 (это Int на моей машине)

Для вызова :code:`f(1, 2)` подходят все три метода.
Давайте посмотрим насколько тип аргумента при вызове :code:`x = 1::Int` «удалён» от декларируемого типа первого аргумента в каждом методе.

- Для метода :code:`f(x, y)` декларируемый тип :code:`x`-а это тип :code:`Any`.
  Расстояние от :code:`Int64` до :code:`Any` в дереве типов равняется пяти.
- Для метода :code:`f(x::Number, y::Number)` подсчёт даёт четыре (расстояние между :code:`Int64` и :code:`Number`).
- Для метода :code:`f(x::Int, y::Number)` подсчёт даёт ноль.

Повторим то же самое для второго аргумента :code:`y`.
Получим расстояния 5, 4 и 4, соответственно.

Сложим теперь эти расстояния.

- У :code:`f(x, y)` расстояние :math:`10 = 5 + 5`.
- У :code:`f(x::Number, y::Number)` расстояние :math:`8 = 4 + 4`.
- У :code:`f(x::Int, y::Number)` расстояние :math:`4 = 0 + 4`.

В итоге получаем, что расстояние от третьего метода :code:`f(x::Int, y::Number)` до аргументов :code:`(1::Int, 2::Int)` самое маленькое.
Поэтому он и выбирается.
В этом смысле (точнее, метрике) он самый близкий.

Аналогично получается для вызова :code:`f(1, 1.5)`, но теперь тип второго аргумента это :code:`Float64`.

- У :code:`f(x, y)` расстояние :math:`9 = 5 + 4`.
- У :code:`f(x::Number, y::Number)` расстояние :math:`7 = 4 + 3`.
- У :code:`f(x::Int, y::Number)` расстояние :math:`3 = 0 + 3`.
  Он и выбирается.

Для последнего вызова :code:`f(1.5, 1.5)` оба аргумента имеют тип :code:`Float64`, и подходят только два метода.

- У :code:`f(x, y)` расстояние :math:`8 = 4 + 4`.
- У :code:`f(x::Number, y::Number)` расстояние :math:`6 = 3 + 3`.

Поэтому выбирается метод :code:`f(x::Number, y::Number)`.

Общий случай (почти)
====================

Если эти примеры обобщить, то мы имеем дело с пространством, состоящем из типов.
Расстояние между двумя типами измеряется по дереву с учётом того, что можно двигаться только от листьев к корню.
Если достичь одного типа из другого так нельзя, то расстояние бесконечное.
(Такая вот топология получается.)

Я выражу это языком... Julia.

.. code-block:: julia-repl
  :linenos: table

  julia> function ρ(x, y)
             x ≡ y && return 0

             if !(x in supertypes(y)) && !(y in supertypes(x))
                 return -1
             end

             return abs(length(supertypes(x)) - length(supertypes(y)))
         end
  ρ (generic function with 1 method)

  julia> ρ(Float64, Any)
  4

  julia> ρ(Float64, Number)
  3

- Строка 2. Проверяем, а не одинаковые ли это типы, тогда расстояние между ними ноль.
- Строки 4:6. Если один тип не содержится в цепочке супертипов (выше по дереву) другого, то они не связаны.
  Значит, расстояние бесконечное (я его обозначил -1).
- Строка 8. А это формула метрики, когда типы связаны в дереве.
  Считаем расстояние от каждого до :code:`Any` и вычитаем.
  (На самом деле, :code:`supertypes(T)` возвращает и сам тип :code:`T`, но при вычитании это компенсируется.)
- В строках 12 и 15 то, что мы считали вручную для случая :code:`f(1.5, 1.5)`.

С одним аргументом разобрались, разберёмся с несколькими.
Несколько аргументов я буду подавать в виде кортежей (tuple).

.. code-block:: julia-repl
  :linenos: table

  julia> function ρ(x::Tuple, y::Tuple)
             length(x) != length(y) && return -1

             dists = ρ.(x, y)

             -1 in dists && return -1

             return sum(dists)
         end
  ρ (generic function with 2 methods)

  julia> ρ((Any, Any), (Int, Int))
  10

  julia> ρ((Number, Number), (Int, Int))
  8

  julia> ρ((Int, Number), (Int, Int))
  4

- Строка 2 обрабатывает случай вообще разных пространств.
  Это когда в методе и вызове не совпадает число аргументов.
- Строка 4 считает расстояние по отдельности.
  Тут используется `broadcast <https://docs.julialang.org/en/v1/manual/arrays/#Broadcasting>`_.
- В строке 6 происходит «если расстояние между какими-то типами бесконечное, то и всё расстояние бесконечное».
- В строке 8 формула метрики для небесконечного случая.
  В итоге она похожа на 1-норму :math:`\sum |x_{i} - y_{i}|`.
- В строках 12, 15 и 18 то, что мы считали вручную для :code:`f(1, 2)`.

Вот так вот.

Подводный камень generic-ов в Julia
===================================

TODO: REVIEW THIS (2025-05-13 by Stepan Zakharov)

Когда мы пишем метод для абстрактного типа, например, :code:`f(x::Real)`, мы пишем его для типов всей ветви, начиная с типа :code:`Real`.

Но есть нюанс.
Метод может не работать для некоторых типов ветви.
Например, наш метод :code:`f(x::Real)` может использовать :code:`eps(x)`, эта функция возвращает машинную точность для значения :code:`x`.
Но :code:`eps(x)` определена только для чисел с плавающей точкой (ну ещё для дат, но щас не об этом).
Поэтому вызов :code:`f(1)` может не сработать, если мы не позаботились о случае :code:`eps(1)`.
На выручку нам может прийти функция :code:`float(x)`, которая приводит число к числу с плавающей точкой.

Или пример попроще.
Скажем, мы написали генератор последовательности Фиббоначи.
Если мы его правильно встроили в дерево типов, то есть шанс, что дефолтные :code:`length(x)`, :code:`first(x)` или :code:`last(x)` отработают правильно (но может не эффективно, как в примере с :code:`mysum`).
А если эти методы из коробки не сработают, то придётся написать свои (наследования то нет).

Итак, когда в Julia метод определён для абстрактного типа аргумента, то это не значит, что всё будет работать.
Такое определение метода лишь выражает *намерение*, что работать должно.
А дальше всё зависит от реализации метода, насколько она действительно generic (то есть, от опыта программиста).

Баг это или фича, решать вам.
Баг в том, что код может упасть в рантайме; компиляция ведь не статическая.
Фича в том, что можно писать интерфейсы: один программист создаёт generic код, а другие накидывают имплементаций.

Подытожим
---------

Выбор метода при вызове функции осуществляется через просмотр дерева типов.
Диспетчер проверяет число аргументов, и если оно правильное, то ищет подходящие методы.
Если таких методов несколько, то выбирается тот, чья сигнатура ближе к сигнатуре вызова.
Близость определяется расстоянием между типами в дереве.

За кадром остаётся много технических деталей.
Я не разработчик языка Julia и не знаю, как они имплементированы.
На моей практике те примеры и эвристики, что я привёл, покрывают 80% работы при написании кода на Julia.
В оставшихся 20% то, с чем я не сталкивался, то, что становится интуитивно понятным с опытом, и то, что приходится гуглить (обычно на `форуме <https://discourse.julialang.org>`_, коммунити супер).

Если понравилось, присоединяйтесь к каналу в `телеге`_.
А ещё можете `финансово поддержать`_ выпуск новых материалов по Julia или вообще.

Напоследок я оставлю пример, который люблю.

----

P.S. Пример обобщённого программирования в Julia
------------------------------------------------

В Julia очень много маленьких функций, которые помогают писать generic код.
Например, самописный generic сумматор выглядит так.

.. code-block:: julia-repl

  julia> function mysum(x)
             acc = zero(eltype(x))
             for xi in x
                 acc += xi
             end
             return acc
         end;

  julia> mysum([1, 2, 3])
  6

  julia> mysum(1:10)
  55

Клёво, да?
Первый пример для массива из трёх элементов.
А во втором :code:`1:10` это арифметическая прогрессия от 1 до 10 с единичным шагом.

Так, стоп.
А зачем нам суммировать все элементы прогрессии, если можно найти сумму за :math:`O(1)` так

.. math::

   \frac{(x_{1} + x_{n}) \times n}{2}

Исправляем!

.. code-block:: julia-repl

  julia> mysum(x::AbstractRange{<:Number}) = (first(x) + last(x)) * length(x) / 2;

  julia> mysum(1:10)
  55.0

Почти готово, но есть косяк — сумма прогрессии целых чисел это всегда целое число, не дробное.
Исправим, накинув ещё один метод!

.. code-block:: julia-repl

  julia> mysum(x::AbstractRange{<:Integer}) = (first(x) + last(x)) * length(x) ÷ 2;

  julia> mysum(1:10)
  55

Вот теперь хорошо.

В дальнейшем можно накинуть низкоуровневых оптимизаций: накидать потоков и `SIMD <https://en.wikipedia.org/wiki/Single_instruction,_multiple_data>`_ инструкций, но щас не об этом.

Итого, сумма элементов массива, как ей и положено, считается за :math:`O(n)`, а сумма арифметической прогрессии за :math:`O(1)`.

.. code-block:: julia-repl

  julia> using BenchmarkTools

  julia> @btime mysum(1:10^6);
    0.791 ns (0 allocations: 0 bytes)

  julia> @btime mysum(1:10^8);
    0.791 ns (0 allocations: 0 bytes)

А Python так может?
===================

К сожалению, нет.
В Python отсутствует magick метод :code:`__sum__`.

.. code-block:: ipython

  In [1]: %timeit sum(range(1, 10**6 + 1))
  9.52 ms ± 36.5 μs per loop (mean ± std. dev. of 7 runs, 100 loops each)

  In [2]: %timeit sum(range(1, 10**8 + 1))
  951 ms ± 1.51 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)

Плак-плак.
Но оно может ему (Пайтону) и не надо.

Диспатч в Python
================

В Python есть диспетчеризация, но она одинарная (single dispatch).
В Python класс это пространство имён, а когда происходит вызов :code:`x + y`, то под капотом интерпретатор делает примерно следующее.

.. code-block:: python

   x + y
   → x.__add__(y)
   → type(x).__add__(x, y)

Где :code:`type(x)` превращается в :code:`int`, :code:`list` или чем там :code:`x` является в рантайме.
Это и есть диспетчеризация, но по типу только первого аргумента.
(Если вы раньше не знали, зачем писать в Python методах :code:`self`, то теперь видите? 😏)

На этом послесловие всё.
