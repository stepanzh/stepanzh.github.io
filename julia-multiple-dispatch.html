<!DOCTYPE html>
<html lang="ru">
  <head>
        <title>stepanzh — Сердце языка Julia — множественная диспетчеризация</title>
      <meta charset="utf-8" />
      <meta name="generator" content="Pelican" />
      <meta name="viewport" content="width=device-width, initial-scale=1.0">

      <!-- Yandex.Metrika counter -->
      <script type="text/javascript" >
         (function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};
         m[i].l=1*new Date();
         for (var j = 0; j < document.scripts.length; j++) {if (document.scripts[j].src === r) { return; }}
         k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})
         (window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");

         ym(99933624, "init", {
              clickmap:true,
              trackLinks:true,
              accurateTrackBounce:true,
              webvisor:true
         });
      </script>
      <noscript><div><img src="https://mc.yandex.ru/watch/99933624" style="position:absolute; left:-9999px;" alt="" /></div></noscript>
      <!-- /Yandex.Metrika counter -->

      <link rel="preconnect" href="https://fonts.googleapis.com">
      <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
      <link href="https://fonts.googleapis.com/css2?family=PT+Mono&family=PT+Sans+Caption:wght@400;700&family=PT+Sans:ital,wght@0,400;0,700;1,400;1,700&display=swap" rel="stylesheet">
      <link rel="stylesheet" type="text/css" href="https://stepanzh.github.io/theme/css/base.css" />
      <link rel="stylesheet" type="text/css" href="https://stepanzh.github.io/theme/css/highlight.css" />

      <!-- icons -->
      <link rel="icon" href="/favicon.ico" sizes="32x32">
      <link rel="apple-touch-icon" href="/apple-touch-icon.png">



    <meta name="description" content="Рассказываю про core design фичу языка Julia — multiple dispatch. Примеры, что это такое и как работает. По полочкам! А в послесловии дружеский подзатыльник Пайтону." />

    <meta name="keywords" content="julia,multiple dispatch,язык программирования,type system,система типов,множественная диспетчеризация" />

  </head>

  <body>
      <header class="page-header">
          <hgroup>
            <h1>
              <a class="site-name" href="https://stepanzh.github.io/">
                <img src="https://stepanzh.github.io/theme/images/galsia-transparent-500x500.png" />
                <span>stepanzh</span>
              </a>
            </h1>
          </hgroup>
          <nav class="nav-global">
            <span class="page-nav__item"><a href="https://stepanzh.github.io/"  aria-current="page" >Главная</a></span>
                <span class="page-nav__item"><a href="https://stepanzh.github.io/pages/about-proportio.html" >Пропорцио</a></span>
                <span class="page-nav__item"><a href="https://stepanzh.github.io/pages/my-projects.html" >Проекты</a></span>
                <span class="page-nav__item"><a href="https://stepanzh.github.io/pages/support-me.html" >Поддержать</a></span>
                <span class="page-nav__item"><a href="https://stepanzh.github.io/pages/contacts.html" >Контакты</a></span>
          </nav>
      </header>
      <main class="page-main">
  <article class="article">
    <header>
      <h2 class="article-heading">Сердце языка Julia — множественная диспетчеризация</h2>
      
    </header>
    <blockquote class="epigraph">
Ву-ху. Первый пост про язык Julia, и сразу в сердце...
Рассказываю про core design фичу — multiple dispatch.
Примеры, что это такое и как работает.
По полочкам!
А в послесловии дружеский подзатыльник Пайтону.</blockquote>
<div class="section" id="julia-1">
<h2>Система типов в Julia</h2>
<p>Чтобы понять, как устроена диспетчеризация в Julia, надо познакомиться с системой типов.</p>
<!--  -->
<blockquote>
В Julia типы организованы в иерархию типа дерево.</blockquote>
<div class="highlight"><pre><span></span>Any
└─ Number
   ├─ Complex
   │  ├─ Complex{Int64}
   │  ├─ Complex{Float64}
   │  └─ ...
   └─ Real
      ├─ AbstractFloat
      │  ├─ BigFloat
      │  ├─ Float16
      │  ├─ Float32
      │  └─ Float64
      ├─ ...
      ├─ Integer
      │  ├─ Bool
      │  ├─ Signed
      │  │  ├─ BigInt
      │  │  ├─ Int128
      │  │  ├─ Int16
      │  │  ├─ Int32
      │  │  ├─ Int64
      │  │  └─ Int8
      │  └─ Unsigned
      │     ├─ UInt128
      │     ├─ UInt16
      │     ├─ UInt32
      │     ├─ UInt64
      │     └─ UInt8
      └─ Rational
         ├─ Rational{Int32}
         ├─ Rational{Int64}
         └─ ...
</pre></div>
<p>Это часть дерева типов, она содержит (почти) все типы для чисел «из коробки».
Например, цепочка от <code>Int64</code> до <code>Any</code> такая.</p>
<div class="highlight"><pre><span></span><span class="gp">julia&gt;</span><span class="w"> </span><span class="kt">Int64</span><span class="w"> </span><span class="o">&lt;:</span><span class="w"> </span><span class="kt">Signed</span><span class="w"> </span><span class="o">&lt;:</span><span class="w"> </span><span class="kt">Integer</span><span class="w"> </span><span class="o">&lt;:</span><span class="w"> </span><span class="kt">Real</span><span class="w"> </span><span class="o">&lt;:</span><span class="w"> </span><span class="kt">Number</span><span class="w"> </span><span class="o">&lt;:</span><span class="w"> </span><span class="kt">Any</span>
<span class="go">true</span>

<span class="gp">julia&gt;</span><span class="w"> </span><span class="n">supertypes</span><span class="p">(</span><span class="kt">Int64</span><span class="p">)</span>
<span class="go">(Int64, Signed, Integer, Real, Number, Any)</span>
</pre></div>
<p>Корень дерева это тип <code>Any</code>.
А все типы в дереве делятся на два вида: абстрактный (abstract) и конкретный (concrete).</p>
<p>Про конкретные типы компилятору известно всё, включая их устройство в памяти.
С ними можно считать в рантайме (runtime; по дефолту Julia компилируется just-in-time).
И они являются листьями в дереве типов.</p>
<p>Абстрактные типы используются для упорядочивания типов в дерево.
Отношение между типами выстраивается как «является подтипом такого-то типа», но Julia не объектно-ориентированный язык, здесь нет привычного для ООП наследования (inheritance).
Например, нельзя со 100% уверенностью написать функцию для чисел <code>Number</code> и быть уверенным, что она будет работать для каждого подтипа.</p>
<p>Однако, создавать функции для абстрактных типов данных можно и полезно.
На этом строится поддержка обобщённой (generic) парадигмы.
Когда компилятор встречает вызов такой функции, он проверяет, все ли есть, чтобы её выполнить для конкретных аргументов.
Если чего-то не хватает, увы, ошибка.
А если всё есть, то компилятор создаёт настолько оптимизированный код, насколько может.</p>
</div>
<div class="section" id="section-1">
<h2>Диспетчеризация</h2>
<p>Я начну с примера.
В языке Julia можно так.</p>
<div class="highlight"><pre><span></span><span class="gp">julia&gt;</span><span class="w"> </span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;default&quot;</span><span class="p">;</span>

<span class="gp">julia&gt;</span><span class="w"> </span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="o">::</span><span class="kt">T</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="o">::</span><span class="kt">T</span><span class="p">)</span><span class="w"> </span><span class="k">where</span><span class="w"> </span><span class="p">{</span><span class="kt">T</span><span class="p">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;default when x and y have same type&quot;</span><span class="p">;</span>

<span class="gp">julia&gt;</span><span class="w"> </span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="o">::</span><span class="kt">Int</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="o">::</span><span class="kt">Int</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;x is Int, y is Int&quot;</span><span class="p">;</span>

<span class="gp">julia&gt;</span><span class="w"> </span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="o">::</span><span class="kt">Int</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="o">::</span><span class="kt">Float64</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;x is Int, y is Float64&quot;</span><span class="p">;</span>

<span class="gp">julia&gt;</span><span class="w"> </span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">z</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;oh my, there are x, y and even z!&quot;</span><span class="p">;</span>

<span class="gp">julia&gt;</span><span class="w"> </span><span class="n">f</span><span class="p">(</span><span class="s">&quot;a&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span>
<span class="go">&quot;default&quot;</span>

<span class="gp">julia&gt;</span><span class="w"> </span><span class="n">f</span><span class="p">(</span><span class="s">&quot;a&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;b&quot;</span><span class="p">)</span>
<span class="go">&quot;default when x and y have same type&quot;</span>

<span class="gp">julia&gt;</span><span class="w"> </span><span class="n">f</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span>
<span class="go">&quot;x is Int, y is Int&quot;</span>

<span class="gp">julia&gt;</span><span class="w"> </span><span class="n">f</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mf">2.0</span><span class="p">)</span>
<span class="go">&quot;x is Int, y is Float64&quot;</span>

<span class="gp">julia&gt;</span><span class="w"> </span><span class="n">f</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span>
<span class="go">&quot;oh my, there are x, y and even z!&quot;</span>
</pre></div>
<p>Выше определена одна функция <code>f</code>.</p>
<div class="highlight"><pre><span></span><span class="gp">julia&gt;</span><span class="w"> </span><span class="n">f</span>
<span class="go">f (generic function with 5 methods)</span>
</pre></div>
<p>И пять методов для неё.</p>
<div class="highlight"><pre><span></span><span class="gp">julia&gt;</span><span class="w"> </span><span class="n">methods</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="go"> [1] f(x::Int64, y::Float64)</span>
<span class="go"> [2] f(x::Int64, y::Int64)</span>
<span class="go"> [3] f(x, y, z)</span>
<span class="go"> [4] f(x::T, y::T) where T</span>
<span class="go"> [5] f(x, y)</span>
</pre></div>
<!--  -->
<blockquote>
Julia не объектно-ориентированный язык: здесь <em>методы принадлежат не объектам, а функциям</em>.</blockquote>
<p>Когда функция вызывается, то диспетчер просматривает, какие есть методы у функции и выбирает тот, который лучшим образом подходит.
«Выбрать лучшим образом» значит выбрать метод, типы аргументов которого наиболее «близки» к типам передаваемых аргументов.
В случае вызова <code>f(1, 2)</code> подходят сразу три метода:</p>
<ul class="simple">
<li><code>f(x, y)</code>,</li>
<li><code>f(x::T, y::T) where {T}</code>,</li>
<li><code>f(x::Int64, y::Int64)</code>.</li>
</ul>
<p>Но вызывается последний, потому что типы аргументов (числа 1 и 2) наиболее близки к паре <code>(Int64, Int64)</code> (вообще, они совпадают с ними).
К тому, что значит «близость» я вернусь позднее.</p>
<!--  -->
<blockquote>
Итак, диспетчеризация это процесс выбора метода для конкретного вызова функции.</blockquote>
<p>А что значит «множественная диспетчеризация» (multiple dispatch)?</p>
<!--  -->
<blockquote>
Множественная диспетчеризация это вид диспетчеризации, который учитывает типы <em>нескольких аргументов</em>.</blockquote>
<p>В случае Julia учитываются типы всех <em>позиционных аргументов</em> (positional arguments), а вот диспетчеризацию для аргументов по ключу (keyword arguments) не завезли.</p>
<div class="section" id="python">
<h3>Диспатч в Python</h3>
<p>В Python тоже есть диспетчеризация, но она одинарная (single dispatch).
В Python класс это пространство имён, а когда происходит вызов, например, <code>x + y</code>, то под капотом интерпретатор делает примерно следующее.</p>
<div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
<span class="n">x</span><span class="o">.</span><span class="fm">__add__</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="nb">type</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="fm">__add__</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
</pre></div>
<p>Где <code>type(x)</code> превращается в <code>int</code>, <code>list</code> или чем там <code>x</code> является в рантайме.
Это и есть диспетчеризация, но по типу только первого аргумента.
(Если вы раньше не знали, зачем писать в Python методах <code>self</code>, то теперь видите? 😏)</p>
</div>
<div class="section" id="section-2">
<h3>Что ещё можно почерпнуть из примеров выше?</h3>
<div class="section" id="section-3">
<h4>Декларация не нужна</h4>
<p>Не обязательно декларировать типы аргументов функции.</p>
<div class="highlight"><pre><span></span><span class="gp">julia&gt;</span><span class="w"> </span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;default&quot;</span><span class="p">;</span>
</pre></div>
<p>На самом деле, декларация здесь есть, но неявная.
Этот пример эквивалентен такому.</p>
<div class="highlight"><pre><span></span><span class="gp">julia&gt;</span><span class="w"> </span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="o">::</span><span class="kt">Any</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="o">::</span><span class="kt">Any</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;default&quot;</span><span class="p">;</span>
</pre></div>
</div>
<div class="section" id="section-4">
<h4>Диспатч на абстрактных типах</h4>
<p>Можно диспетчеризовываться не только на конкретных, но и на абстрактных типах.</p>
<div class="highlight"><pre><span></span><span class="gp">julia&gt;</span><span class="w"> </span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;default&quot;</span><span class="p">;</span><span class="w">  </span><span class="c"># f(x::Any, y::Any)</span>

<span class="gp">julia&gt;</span><span class="w"> </span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="o">::</span><span class="kt">Int</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="o">::</span><span class="kt">Int</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;x is Int, y is Int&quot;</span><span class="p">;</span>

<span class="gp">julia&gt;</span><span class="w"> </span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="o">::</span><span class="kt">Real</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="o">::</span><span class="kt">Real</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;x and y are real numbers&quot;</span><span class="p">;</span>
</pre></div>
<div class="section" id="section-5">
<h5>Чуть-чуть про компиляцию</h5>
<p>Когда происходит вызов функции и метод выбран, компилятор создаёт машинный код для него.
Повторная компиляция для вызова функции от тех же типов больше не требуется, можно <em>сразу использовать машинный код</em>.</p>
<p>Если при этом тип возвращаемого значения не зависит от значений аргументов (а определяется только их типами), то машинный код будет эффективным.
Функции, которые написаны таким образом, называются <em>стабильными по типу</em> (type stable).
Если ситуация обратная, то быстродействие падает примерно до уровня Python, потому что значения боксятся, и их тип приходится проверять в рантайме.</p>
<p>Типичный пример — квадратный корень <code>sqrt(x)</code>.
Для неотрицательных действительных чисел он всегда возвращает float-число.
А вот отрицательные нужно обернуть в комплексное число.
Будь иначе, стабильность бы была потеряна, ведь тогда <code>sqrt(1)</code> возвращал бы float, а <code>sqrt(-1)</code> — complex, в то время как аргумент в обоих случаях имеет тип <code>Int</code>.</p>
</div>
</div>
<div class="section" id="section-6">
<h4>Диспатч на количестве аргументов</h4>
<p>Методы могут иметь разное количество аргументов, а диспетчеризация это учитывает.</p>
<div class="highlight"><pre><span></span><span class="gp">julia&gt;</span><span class="w"> </span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;default&quot;</span><span class="p">;</span>

<span class="gp">julia&gt;</span><span class="w"> </span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">z</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;oh my, there are x, y and even z!&quot;</span><span class="p">;</span>
</pre></div>
</div>
<div class="section" id="generic-programming-included">
<h4>Generic programming included</h4>
<p>Julia поддерживает обобщённую (generic) парадигму.</p>
<div class="highlight"><pre><span></span><span class="gp">julia&gt;</span><span class="w"> </span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="o">::</span><span class="kt">T</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="o">::</span><span class="kt">T</span><span class="p">)</span><span class="w"> </span><span class="k">where</span><span class="w"> </span><span class="p">{</span><span class="kt">T</span><span class="p">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;default when x and y have same type&quot;</span><span class="p">;</span>
</pre></div>
<p>Здесь в одной строчке определяется семейство методов, у которых два аргумента, имеющих одинаковый тип (и он назван <code>T</code>).
То есть метод подходит для <code>(Int, Int)</code>, <code>(Float64, Float64)</code>, <code>(String, String)</code> и так далее.</p>
<p>Кстати, тип аргументов доступен как в рантайме так и во время компиляции.</p>
<div class="highlight"><pre><span></span><span class="gp">julia&gt;</span><span class="w"> </span><span class="n">atruntime</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">typeof</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>

<span class="gp">julia&gt;</span><span class="w"> </span><span class="n">atcompiletime</span><span class="p">(</span><span class="n">x</span><span class="o">::</span><span class="kt">T</span><span class="p">)</span><span class="w"> </span><span class="k">where</span><span class="w"> </span><span class="p">{</span><span class="kt">T</span><span class="p">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">T</span><span class="p">;</span>

<span class="gp">julia&gt;</span><span class="w"> </span><span class="n">atruntime</span><span class="p">(</span><span class="nb">π</span><span class="p">)</span>
<span class="go">Irrational{:π}</span>

<span class="gp">julia&gt;</span><span class="w"> </span><span class="n">atcompiletime</span><span class="p">(</span><span class="nb">π</span><span class="p">)</span>
<span class="go">Irrational{:π}</span>
</pre></div>
<p>Знать типы во время компиляции бывает необходимо, чтобы дешёво извлечь информацию об аргументах.
Например, так можно узнать размерность массива <code>ndims(x)</code> или тип его элементов <code>eltype(x)</code>, поэтому что информация об этом зашита в типе.</p>
</div>
</div>
</div>
<div class="section" id="section-7">
<h2>Как выбирается метод?</h2>
<p>Перейдём к тому, как выбирается метод среди нескольких.</p>
<div class="section" id="section-8">
<h3>Пример попроще</h3>
<p>Пусть у нас есть функция с одним аргументом и несколькими методами.</p>
<ul class="simple">
<li><code>g(x)</code></li>
<li><code>g(x::Number)</code></li>
<li><code>g(x::Float64)</code></li>
</ul>
<p>Если вызвать функцию от целого числа <code>g(1)</code>, то применится метод <code>g(::Number)</code>.
Логика следующая.</p>
<ul class="simple">
<li>Подходят два метода: <code>g(::Any)</code> и <code>g(::Number)</code>.</li>
<li>Тип <code>Int64</code> в дереве ближе к <code>Number</code>, чем к <code>Any</code>.</li>
<li>Поэтому берём его.</li>
</ul>
</div>
<div class="section" id="section-9">
<h3>Пример посложнее</h3>
<p>А что если аргументов несколько?</p>
<div class="highlight"><pre><span></span><span class="gp">julia&gt;</span><span class="w"> </span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;default&quot;</span><span class="p">;</span>

<span class="gp">julia&gt;</span><span class="w"> </span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="o">::</span><span class="kt">Number</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="o">::</span><span class="kt">Number</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;Number &amp; Number&quot;</span><span class="p">;</span>

<span class="gp">julia&gt;</span><span class="w"> </span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="o">::</span><span class="kt">Int</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="o">::</span><span class="kt">Number</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;Int &amp; Number&quot;</span><span class="p">;</span>

<span class="gp">julia&gt;</span><span class="w"> </span><span class="n">f</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;a&quot;</span><span class="p">)</span>
<span class="go">&quot;default&quot;</span>

<span class="gp">julia&gt;</span><span class="w"> </span><span class="n">f</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span>
<span class="go">&quot;Int &amp; Number&quot;</span>

<span class="gp">julia&gt;</span><span class="w"> </span><span class="n">f</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mf">1.5</span><span class="p">)</span>
<span class="go">&quot;Int &amp; Number&quot;</span>

<span class="gp">julia&gt;</span><span class="w"> </span><span class="n">f</span><span class="p">(</span><span class="mf">1.5</span><span class="p">,</span><span class="w"> </span><span class="mf">1.5</span><span class="p">)</span>
<span class="go">&quot;Number &amp; Number&quot;</span>
</pre></div>
<p>Здесь у функции три метода.</p>
<p>С первым вызовом <code>f(1, &quot;a&quot;)</code> всё понятно, второй аргумент это строка, и только один метод подходит из трёх.</p>
<p>Для оставшихся случаев давайте обратимся к дереву типов.
Я намеренно оставил только те типы, которые участвуют в оставшихся случаях: <code>Any</code>, <code>Number</code>, <code>Int64</code> (он же <code>Int</code>) и <code>Float64</code>.</p>
<div class="highlight"><pre><span></span>Any
└─ Number
   └─ Real
      ├─ AbstractFloat
      │  └─ Float64
      └─ Integer
         └─ Signed
            └─ Int64 (это Int на моей машине)
</pre></div>
<p>Для вызова <code>f(1, 2)</code> подходят все три метода.
Давайте посмотрим насколько тип аргумента при вызове <code>x = 1::Int</code> «удалён» от декларируемого типа первого аргумента в каждом методе.</p>
<ul class="simple">
<li>Для метода <code>f(x, y)</code> декларируемый тип <code>x</code>-а это тип <code>Any</code>.
Расстояние от <code>Int64</code> до <code>Any</code> в дереве типов равняется пяти.</li>
<li>Для метода <code>f(x::Number, y::Number)</code> подсчёт даёт четыре (расстояние между <code>Int64</code> и <code>Number</code>).</li>
<li>Для метода <code>f(x::Int, y::Number)</code> подсчёт даёт ноль.</li>
</ul>
<p>Повторим то же самое для второго аргумента <code>y</code>.
Получим расстояния 5, 4 и 4, соответственно.</p>
<p>Сложим теперь эти расстояния.</p>
<ul class="simple">
<li>У <code>f(x, y)</code> расстояние <span class="math">\(10 = 5 + 5\)</span>.</li>
<li>У <code>f(x::Number, y::Number)</code> расстояние <span class="math">\(8 = 4 + 4\)</span>.</li>
<li>У <code>f(x::Int, y::Number)</code> расстояние <span class="math">\(4 = 0 + 4\)</span>.</li>
</ul>
<p>В итоге получаем, что расстояние от третьего метода <code>f(x::Int, y::Number)</code> до аргументов <code>(1::Int, 2::Int)</code> самое маленькое.
Поэтому он и выбирается.
В этом смысле (точнее, метрике) он самый близкий.</p>
<p>Аналогично получается для вызова <code>f(1, 1.5)</code>, но теперь тип второго аргумента это <code>Float64</code>.</p>
<ul class="simple">
<li>У <code>f(x, y)</code> расстояние <span class="math">\(9 = 5 + 4\)</span>.</li>
<li>У <code>f(x::Number, y::Number)</code> расстояние <span class="math">\(7 = 4 + 3\)</span>.</li>
<li>У <code>f(x::Int, y::Number)</code> расстояние <span class="math">\(3 = 0 + 3\)</span>.
Он и выбирается.</li>
</ul>
<p>Для последнего вызова <code>f(1.5, 1.5)</code> оба аргумента имеют тип <code>Float64</code>, и подходят только два метода.</p>
<ul class="simple">
<li>У <code>f(x, y)</code> расстояние <span class="math">\(8 = 4 + 4\)</span>.</li>
<li>У <code>f(x::Number, y::Number)</code> расстояние <span class="math">\(6 = 3 + 3\)</span>.</li>
</ul>
<p>Поэтому выбирается метод <code>f(x::Number, y::Number)</code>.</p>
</div>
<div class="section" id="section-10">
<h3>Общий случай (почти)</h3>
<p>Если эти примеры обобщить, то мы имеем дело с пространством, состоящем из типов.
Расстояние между двумя типами измеряется по дереву с учётом того, что можно двигаться только от листьев к корню.
Если достичь одного типа из другого так нельзя, то расстояние бесконечное.
(Такая вот топология получается.)</p>
<p>Я выражу это языком... Julia.</p>
<div class="highlight"><pre><span></span><span class="gp">julia&gt;</span><span class="w"> </span><span class="k">function</span><span class="w"> </span><span class="n">ρ</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">)</span>
<span class="w">           </span><span class="n">indx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">findfirst</span><span class="p">(</span><span class="o">==</span><span class="p">(</span><span class="n">x</span><span class="p">),</span><span class="w"> </span><span class="n">supertypes</span><span class="p">(</span><span class="n">y</span><span class="p">))</span>
<span class="w">           </span><span class="o">!</span><span class="n">isnothing</span><span class="p">(</span><span class="n">indx</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">indx</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span>

<span class="go">           indy = findfirst(==(y), supertypes(x))</span>
<span class="go">           !isnothing(indy) &amp;&amp; return indy - 1</span>

<span class="go">           return -1</span>
<span class="go">       end</span>
<span class="go">ρ (generic function with 1 method)</span>

<span class="gp">julia&gt;</span><span class="w"> </span><span class="n">ρ</span><span class="p">(</span><span class="kt">Float64</span><span class="p">,</span><span class="w"> </span><span class="kt">Any</span><span class="p">)</span>
<span class="go">4</span>

<span class="gp">julia&gt;</span><span class="w"> </span><span class="n">ρ</span><span class="p">(</span><span class="kt">Float64</span><span class="p">,</span><span class="w"> </span><span class="kt">Number</span><span class="p">)</span>
<span class="go">3</span>
</pre></div>
<p>Здесь сначала пробуем найти «где тип <code>x</code> среди супертипов игрека».
Если нашли, значит <code>x</code> находится в ветви от <code>y</code> до <code>Any</code>, тогда и возвращаем позицию <code>x</code> минус 1, это и будет расстоянием от <code>y</code> до <code>x</code>.
А если не нашли, пробуем искать <code>y</code> в ветви от <code>x</code> до <code>Any</code>.
Если и так не нашли, возвращаем <code>-1</code>, как признак бесконечности.
Примеры я привёл те, что считал вручную для <code>f(1.5, 1.5)</code>.</p>
<p>С одним аргументом разобрались, разберёмся с несколькими.
Несколько аргументов я буду подавать в виде кортежей (tuple).</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span></pre></div></td><td class="code"><div><pre><span></span><span class="gp">julia&gt;</span><span class="w"> </span><span class="k">function</span><span class="w"> </span><span class="n">ρ</span><span class="p">(</span><span class="n">x</span><span class="o">::</span><span class="kt">Tuple</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="o">::</span><span class="kt">Tuple</span><span class="p">)</span>
<span class="w">           </span><span class="n">length</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">length</span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="o">-</span><span class="mi">1</span>

<span class="go">           dists = ρ.(x, y)</span>

<span class="go">           -1 in dists &amp;&amp; return -1</span>

<span class="go">           return sum(dists)</span>
<span class="go">       end</span>
<span class="go">ρ (generic function with 2 methods)</span>

<span class="gp">julia&gt;</span><span class="w"> </span><span class="n">ρ</span><span class="p">((</span><span class="kt">Any</span><span class="p">,</span><span class="w"> </span><span class="kt">Any</span><span class="p">),</span><span class="w"> </span><span class="p">(</span><span class="kt">Int</span><span class="p">,</span><span class="w"> </span><span class="kt">Int</span><span class="p">))</span>
<span class="go">10</span>

<span class="gp">julia&gt;</span><span class="w"> </span><span class="n">ρ</span><span class="p">((</span><span class="kt">Number</span><span class="p">,</span><span class="w"> </span><span class="kt">Number</span><span class="p">),</span><span class="w"> </span><span class="p">(</span><span class="kt">Int</span><span class="p">,</span><span class="w"> </span><span class="kt">Int</span><span class="p">))</span>
<span class="go">8</span>

<span class="gp">julia&gt;</span><span class="w"> </span><span class="n">ρ</span><span class="p">((</span><span class="kt">Int</span><span class="p">,</span><span class="w"> </span><span class="kt">Number</span><span class="p">),</span><span class="w"> </span><span class="p">(</span><span class="kt">Int</span><span class="p">,</span><span class="w"> </span><span class="kt">Int</span><span class="p">))</span>
<span class="go">4</span>
</pre></div></td></tr></table></div>
<ul class="simple">
<li>Строка 2 обрабатывает случай вообще разных пространств.
Это когда в методе и вызове не совпадает число аргументов.</li>
<li>Строка 4 считает расстояние по отдельности.
Тут используется <a class="reference external" href="https://docs.julialang.org/en/v1/manual/arrays/#Broadcasting">broadcast</a>.</li>
<li>В строке 6 происходит «если расстояние между какими-то типами бесконечное, то и всё расстояние бесконечное».</li>
<li>В строке 8 формула метрики для небесконечного случая.
В итоге она похожа на 1-норму <span class="math">\(\sum |x_{i} - y_{i}|\)</span>.</li>
<li>В строках 12, 15 и 18 то, что мы считали вручную для <code>f(1, 2)</code>.</li>
</ul>
<p>Вот так вот и определяется «близость» типов.
А точнее, близость сигнатуры вызова к сигнатуре метода.</p>
</div>
</div>
<div class="section" id="section-11">
<h2>Подытожим</h2>
<p>Выбор метода при вызове функции осуществляется через просмотр дерева типов.
Диспетчер проверяет число аргументов, и если оно правильное, то ищет подходящие методы.
Если таких методов несколько, то выбирается тот, чья сигнатура ближе к сигнатуре вызова.
Близость определяется расстоянием между типами в дереве.</p>
<p>За кадром остаётся много технических деталей.
Я не разработчик языка Julia и не знаю, как они имплементированы.
На моей практике те примеры и эвристики, что я привёл, покрывают 80% работы при написании кода на Julia.
В оставшихся 20% то, с чем я не сталкивался, то, что становится интуитивно понятным с опытом, и то, что приходится гуглить (обычно на <a class="reference external" href="https://discourse.julialang.org">форуме</a>, коммунити супер).</p>
<p>Если понравилось, присоединяйтесь к каналу в <a class="reference external" href="https://t.me/stepanzh_blog/">телеге</a>.
А ещё можете <a class="reference external" href="https://stepanzh.github.io/pages/support-me.html">финансово поддержать</a> выпуск новых материалов по Julia или вообще.</p>
<p>Напоследок я оставлю пример, который люблю.</p>
</div>
<hr class="docutils" />
<div class="section" id="p-s-julia">
<h2>P.S. Пример обобщённого программирования в Julia</h2>
<p>В Julia очень много маленьких функций, которые помогают писать generic код.
Например, самописный generic сумматор выглядит так.</p>
<div class="highlight"><pre><span></span><span class="gp">julia&gt;</span><span class="w"> </span><span class="k">function</span><span class="w"> </span><span class="n">mysum</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="w">           </span><span class="n">acc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">zero</span><span class="p">(</span><span class="n">eltype</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
<span class="w">           </span><span class="k">for</span><span class="w"> </span><span class="n">xi</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">x</span>
<span class="w">               </span><span class="n">acc</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">xi</span>
<span class="w">           </span><span class="k">end</span>
<span class="w">           </span><span class="k">return</span><span class="w"> </span><span class="n">acc</span>
<span class="w">       </span><span class="k">end</span><span class="p">;</span>

<span class="gp">julia&gt;</span><span class="w"> </span><span class="n">mysum</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">])</span>
<span class="go">6</span>

<span class="gp">julia&gt;</span><span class="w"> </span><span class="n">mysum</span><span class="p">(</span><span class="mi">1</span><span class="o">:</span><span class="mi">10</span><span class="p">)</span>
<span class="go">55</span>
</pre></div>
<p>Клёво, да?
Первый пример для массива из трёх элементов.
А во втором <code>1:10</code> это арифметическая прогрессия от 1 до 10 с единичным шагом.</p>
<p>Так, стоп.
А зачем нам суммировать все элементы прогрессии, если можно найти сумму за <span class="math">\(O(1)\)</span> так</p>
<div class="math">
\begin{equation*}
\frac{(x_{1} + x_{n}) \times n}{2}
\end{equation*}
</div>
<p>Исправляем!</p>
<div class="highlight"><pre><span></span><span class="gp">julia&gt;</span><span class="w"> </span><span class="n">mysum</span><span class="p">(</span><span class="n">x</span><span class="o">::</span><span class="kt">AbstractRange</span><span class="p">{</span><span class="o">&lt;:</span><span class="kt">Number</span><span class="p">})</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">first</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">last</span><span class="p">(</span><span class="n">x</span><span class="p">))</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">length</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>

<span class="gp">julia&gt;</span><span class="w"> </span><span class="n">mysum</span><span class="p">(</span><span class="mi">1</span><span class="o">:</span><span class="mi">10</span><span class="p">)</span>
<span class="go">55.0</span>
</pre></div>
<p>Почти готово, но есть косяк — сумма прогрессии целых чисел это всегда целое число, не дробное.
Исправим, накинув ещё один метод!</p>
<div class="highlight"><pre><span></span><span class="gp">julia&gt;</span><span class="w"> </span><span class="n">mysum</span><span class="p">(</span><span class="n">x</span><span class="o">::</span><span class="kt">AbstractRange</span><span class="p">{</span><span class="o">&lt;:</span><span class="kt">Integer</span><span class="p">})</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">first</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">last</span><span class="p">(</span><span class="n">x</span><span class="p">))</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">length</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">÷</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>

<span class="gp">julia&gt;</span><span class="w"> </span><span class="n">mysum</span><span class="p">(</span><span class="mi">1</span><span class="o">:</span><span class="mi">10</span><span class="p">)</span>
<span class="go">55</span>
</pre></div>
<p>Вот теперь хорошо.
В дальнейшем можно накинуть низкоуровневых оптимизаций: накидать потоков и <a class="reference external" href="https://en.wikipedia.org/wiki/Single_instruction,_multiple_data">SIMD</a> инструкций (если компилятор не сделает это за нас), но щас не об этом.</p>
<p>Итого, сумма элементов массива, как ей и положено, считается за <span class="math">\(O(n)\)</span>, а сумма арифметической прогрессии за <span class="math">\(O(1)\)</span>.</p>
<div class="highlight"><pre><span></span><span class="gp">julia&gt;</span><span class="w"> </span><span class="k">using</span><span class="w"> </span><span class="n">BenchmarkTools</span>

<span class="gp">julia&gt;</span><span class="w"> </span><span class="nd">@btime</span><span class="w"> </span><span class="n">mysum</span><span class="p">(</span><span class="mi">1</span><span class="o">:</span><span class="mi">10</span><span class="o">^</span><span class="mi">6</span><span class="p">);</span>
<span class="go">  0.791 ns (0 allocations: 0 bytes)</span>

<span class="gp">julia&gt;</span><span class="w"> </span><span class="nd">@btime</span><span class="w"> </span><span class="n">mysum</span><span class="p">(</span><span class="mi">1</span><span class="o">:</span><span class="mi">10</span><span class="o">^</span><span class="mi">8</span><span class="p">);</span>
<span class="go">  0.791 ns (0 allocations: 0 bytes)</span>
</pre></div>
<div class="section" id="python-1">
<h3>А Python так может?</h3>
<p>К сожалению, нет.
В Python отсутствует magick метод <code>__sum__</code>.</p>
<div class="highlight"><pre><span></span><span class="gp">In [1]: </span><span class="o">%</span><span class="k">timeit</span> sum(range(1, 10**6 + 1))
<span class="go">9.52 ms ± 36.5 μs per loop (mean ± std. dev. of 7 runs, 100 loops each)</span>

<span class="gp">In [2]: </span><span class="o">%</span><span class="k">timeit</span> sum(range(1, 10**8 + 1))
<span class="go">951 ms ± 1.51 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)</span>
</pre></div>
<p>Плак-плак.
Но оно может Пайтону и не надо.</p>
<p>На этом послесловие всё.</p>
</div>
</div>
<script type='text/javascript'>if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width < 768) ? "left" : align;
        indent = (screen.width < 768) ? "0em" : indent;
        linebreak = (screen.width < 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
</script>
    <footer class="article-footer">
      <p class="article-date">
        <time datetime="2025-05-14T00:00:00+03:00">2025-05-14</time>      </p>
      <section class="article-footer__actions">
        <div><a href="https://stepanzh.github.io/pages/support-me.html" rel="bookmark">❤️ Поблагодарить автора</a></div>
        <div><a href="https://t.me/stepanzh_blog" rel="nofollow">👀 Подписаться на новости</a></div>
      </section>
    </footer>
  </article>
      </main>
      <footer class="page-footer">
          <p>&copy; Захаров Степан</p>
          <p>Сайт создан с помощью <a target="_blank" rel="nofollow" href="https://getpelican.com/">Pelican</a></p>
      </footer>
  </body>
</html>